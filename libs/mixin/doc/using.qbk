[/
 Copyright (c) 2013 Borislav Stanimirov, Zahary Karadjov

 Distributed under the Boost Software License, Version 1.0.
 See accompanying file LICENSE_1_0.txt or copy at
 http:#www.boost.org/LICENSE_1_0.txt
/]

[section:using Using Boost.Mixin]

[section:quickstart Quickstart]

To make use of the most basic features of Boost.Mixin you need to create an
object add some mixins to it and then call some messages.

[section:create_object Creating an object]

Creating an object is pretty straightforward. You can just instantiate a
`boost::mixin::object` as you would any other class:

    boost::mixin::object a;
    boost::mixin::object* b = new boost::mixin::object;

Both `a` and `b` will be plain empty objects.

[endsect]

[section:add_mixin Adding mixins to an object]

To add mixins to an object, you first need to have some mixin classes. Any class
can be turned into a mixin with the following two macros.

* `BOOST_DECLARE_MIXIN(someclass)` - declares that `someclass` is a mixin type.
The best place for this macro is in some header. The header needs to be included
in places where this mixin is mentioned. Such a place would be where we add the
mixin to an object.
* `BOOST_DEFINE_MIXIN(someclass, features)` - defines the mixin type. Place this
macro in a compiled unit (like a .cpp file). The features of a mixin are an
ampersand separated list of the mixin's specific characteristics. There are
various possible features for a mixin type, but for now we'll focus on the
messages. If a mixin has no features you should use `boost::mixin::none`

So, lets see how we can define a mixin that gives a name to our object.

/named_mixin.hpp/

    #pragma once

    BOOST_DECLARE_MIXIN(named);

/named.hpp/

    #pragma once

    class named
    {
    public:
        const std::string& name() const;
        void set_name(const std::string& new_name);

    private:
        std::string _name;
    };

/named.cpp/

    #include "named_mixin.hpp"
    #include "named.hpp"

    using namespace std;
    using namespace boost::mixin;

    const string& named::name() const
    {
        return _name;
    }

    void named::set_name(const string& new_name)
    {
        _name = new_name;
    }

    BOOST_DEFINE_MIXIN(named, none);

That's it. Now we can add the `named` mixin to an object of ours.

The simplest way of adding mixins to object is with the `mutate` class. If we
include `named_mixin.hpp` somewhere in our code, we could write this:

    using namespace boost::mixin;
    object obj;
    mutate(obj).add<named>();

And now the object `obj` has a mixin of type `named` in it.

[endsect]

[section:add_message Adding and calling messages]

Using the code from above we could get an objects name like this:

    const string& n = obj.get<named>().name();

This is not very useful, because not only do we have to include `named.hpp`, but
we also have to be sure (or at least check) that the object has a mixin of type
`named`. Here's where the messages come into play.

Using messages, you would be able to write code like this:

    set_name(obj, "John");
    const string& n = name(obj);

First we have to declare what messages are there. There are macros to declare
and define messages.

[endsect]

[endsect]

[section:tips_tricks Tips and tricks]

* When adding the same set of messages to multiple mixins, create a define of
them all. Like: `#define transform_messages set_position_msg & set_orientation_msg`.
Then use it like this `BOOST_DEFINE_MIXIN(x, some_messages & transform_messages);`
* Instead of using the long message declaration macros, consider defining your
own. Maybe something like `#define BM_C_MSG_1 BOOST_MIXIN_CONST_MESSAGE_1`
* Prefer using `object_type_template`-s instead of mutating each new object.
* Prefer using `same_type_mutator` when mutating multiple objects of the same
type.


[endsect]

[endsect]