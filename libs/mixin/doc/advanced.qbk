[/
 Copyright (c) 2013 Borislav Stanimirov, Zahary Karadjov

 Distributed under the Boost Software License, Version 1.0.
 See accompanying file LICENSE_1_0.txt or copy at
 http://www.boost.org/LICENSE_1_0.txt
/]

[section:advanced Advanced topics]


[section:performance Performance]
[indexterm performance]

[section:msg_perf Message performance]
[indexterm2 message..performance]

The performance of messages is indeed slower than regular function calls and even
virtual function calls. Even though a call's algorithmic complexity is still
O(1), a number of memory indirections happen in order to call the actual method
behind the message.

Unfortunately it's hard to estimate exactly how much slower the message call is.
With perfect cache locality and compiler optimizations a message call will take
about 15 cycles, compared to about 5-7 cycles for a virtual call and 10-12
cycles for a std::function call. 15 cycles on a modern 2.8 GHz processor take
about 5 nanoseconds to execute, which is a negligible cost for a call.

Unfortunately perfect cache locality is hard to come by, and especially hard in
polymorphic code. In an amortized test with potential cache misses
for all calls, Boost.Mixin messages take on average about 120 cycles (40
nanoseconds on the same processor), compared to 90 cycles on average for virtual
calls and 115 cycles for a `std::function` call.

So, generally speaking if the programmer doesn't take special care to achieve
cache locality for their object lists, a message call is about 2 times slower
than a regular method call and about 1.3 times slower than a virtual call and
abotut as fast as a `std::function` call, which
again can be called negligible.

As, we've mentionet before if cache locality is an absolutely
critical feature for the desired performance, mixin messages, virtual calls,
`std::function`, and other types of polymorphism will almost certainly
be detrimental for this code, and the programmers are advised to do something
else.

[section:msg_perf_test Message performance test]

The message performance test compares regular method calls vs virtual method
calls vs `std::function` calls vs Boost.Mixin unicast message calls.

It creates 10,000 objects, then processes them until 100,000,000 calls are made.
The actuall calls perform a simple adition whose cost compared with the call
cost is indeed negligible.

The regular method calls are what you would have in cache-locality optimized
setting -- they are methods in an array of objects of the the same type stored
by value.

The other calls are polymorphic and their arrays store objects by address that
can be one of two types.

Here are some test results:

* OS: Ubuntu 13.04
* CPU: AMD FX X8 8150
* Compiler: g++ (Ubuntu/Linaro 4.7.3-1ubuntu1)
* Debug compilation parameters: `-fexceptions -g`
* Release compilation parameters `-fexceptions -O2`

[table
    [
        [Method]
        [Debug]
        [Debug mean]
        [Release]
        [Release mean]
    ]
    [
        [Regular]
        [2345 ms]
        [23 ns]
        [1088 ms]
        [11 ns]
    ]
    [
        [Virtual]
        [2894 ms]
        [29 ns]
        [1580 ms]
        [16 ns]
    ]
    [
        [`std::function`]
        [11910 ms]
        [119 ns]
        [1966 ms]
        [20 ns]
    ]
    [
        [Boost.Mixin msg]
        [4942 ms]
        [50 ns]
        [1986 ms]
        [20 ns]
    ]
]

* OS: Windows 7
* CPU: AMD FX 4100
* Compiler: msvc 9 (Visual Studio 2008)
* Debug compilation parameters: Standard (`/Od /EHsc /RTC1 /MDd /ZI`)
* Release compilation parameters: Standard, but with no link time code generation (`/O2 /Oi /EHsc /MD /Gy /Zi`)

[table
    [
        [Method]
        [Debug]
        [Debug mean]
        [Release]
        [Release mean]
    ]
    [
        [Regular]
        [4103 ms]
        [41 ns]
        [1419 ms]
        [14 ns]
    ]
    [
        [Virtual]
        [5585 ms]
        [55 ns]
        [1560 ms]
        [16 ns]
    ]
    [
        [`boost::function`]
        [45240 ms]
        [452 ns]
        [1919 ms]
        [19 ns]
    ]
    [
        [Boost.Mixin msg]
        [25100 ms]
        [251 ns]
        [2714 ms]
        [27 ns]
    ]
]

[endsect]

[section:optimize_msg Optimizing message calls]

The stand-alone functions generated for messages typically have an `if`
statement in them. It's there so as to throw an exception if none of the mixins
in an object implements the message. If you disable the library's exceptions
those `if`-s will be converted to `assert`-s (which in non-debug compilations
are simply ignored).

If you don't want to recompile the library with exceptions disabled, or if you
just want all other exceptions, but not these, you can disable the throwing of
exceptions from the message functions fi you define `BOOST_MIXIN_NO_MSG_THROW`
/before/ including the Boost.Mixin headers.

Note that if you disable the exceptions from the message functions, calling a
message on an object that doesn't implement it, will certainly lead to undefined
behaviour and crashes.

Also have in mind, that removing the 'if'-s will improve the performance by only
a small amount of nanoseconds per message call on a modern CPU. Situations where
such a thing could be significant should be very very rare.

[endsect]

[endsect]

[section:mutation_perf Mutation performance]

[endsect]

[endsect]

[section:allocators Using custom allocators]
[endsect]

[section:dynlib Dynamic libraries and program plugins]
[endsect]

[section:implementation Implementation notes]

The overall structure of the library is based on a main class called `domain`
which holds all registered mixins and messages, and keeps the type registry.

[section:reg Mixin and feature registration]

The `BOOST_DEFINE_MIXIN` macro instantiates a class that is similar to a
metafunction, as its only purpose is to globally instantiate itself, which in
turn will lead to `domain::register_mixin_type` being called.

It also generates a function that registers the mixin features.

`domain::register_mixin_type` is a template method and it will appropriately
fill a structure, containing the mixin type information -- name, constructor,
destructor, id, and will also call the generated function that registers its
features.

The feature registration is composed of two parts: one global - to introduce the
feature to the domain, and local called for the specific mixin type being
registerd. This means that a feature is globally registered multiple times -
once for each of its uses for a mixin type. The first of those times will give
it an id and fill the feature information structure appropriately. The other
global registrations of a feature will see that it has a valid id, and will
simply skip the rest of the code.

The local feature registration is performed by the class `feature_parser` that
has overloads for the supported mixin features: currently messages and
allocators. The allocator registration is simple it just sets the allocator
member in the mixin type information structure to the appropriate value.

The message registration generates a caller function, based on the specific
mixin. This caller function is a speficic instantiation of a template function
which is generated by the message declaration macros. It's template parameters
are the mixin type and the actual member function in the mixin. The caller is
then cast to `void (*)()` to be stored in a vector in the mixin type information
structure along with the caller functions for all of its messages.

This process of creating a caller function is based on the article
[@http://www.codeproject.com/Articles/11015/The-Impossibly-Fast-C-Delegates
The Impossibly Fast C++ Delegates] by Sergey Ryazanov.

[endsect]

[section:reg Mixin and message id-s]

Each newly registered mixin and message get an id. The id-s are consecutive
indices in arrays (of `mixin_type_info` and `message_t` respectively) in the
domain. Thus getting the information for a mixin or a message through its id
is a O(1) operation.

The maximum numbers of registered messages and mixins are fixed through the
constants `BOOST_MIXIN_MAX_MIXINS` and `BOOST_MIXIN_MAX_MESSAGES` in
`config.hpp`.

This allows us to have fixed-size arrays for both in the domain and per object
type.

[endsect]

[section:reg Mutation and type information]

A new object type is initially identified via a bitset per mixin. The domain
contains an unordered (hash) map where the key is such a bitset, and the value
is an object type info.

The object type info consists of such a bitset (to mark which mixins are
available in this type), a compact vector of mixin type information structures
a cross indexing array (to indicate which mixin data is at which position in the
compact array), and a call table.

The call table plays the same role as the virtual table in C++. It's a fixed
size array for every message with non-null values for the messages that are
implemented by that type. An element of that array is of type
`call_table_entry`. This is a union that, based on whether the message is a
unicast or a multicast, will contain the message data or a begin and an end
for a buffer or message datas.

When a type is requested for an object it's first checked whether such a
combination of mixins is an existing type. If not a new object type is created.
This fills the mixin information bitset, vector and cross indexing array and
then fills the call table. It will allocate a single buffer for all multicast
messages within that type. When filling the call table the type creation process
will choose the top priority unicast messages and sort the multicasts by
priority. It will throw and exception if same-priority unicasts exist.

After the type is available the object data needs to be filled. The object
consists of a pointer to its type and an array of the structure
`mixin_data_in_object`. This structure wraps a simple buffer that contains the
mixin instance and a pointer to the owning object right in front of it. This
is required for the need to get the owning object from within the code of the
mixin class (made through `bm_this` or `object_of`). Thus, getting the owning
object from the mixin is an offset from the `this` pointer.

[endsect]

[section:msg_call Calling messages]

The message calling happens through the message functions which are generated
by the message declaration macros.

The call consits of the following steps:
* Get the message info through a function generated by the message definition
macro
* Get the call table entry for this message from the object's type
* Get the mixin info and the caller function from the call table entry
* Get the mixin pointer from the object, based on the mixin info
* Cast the caller function from `void (*)()` to the appropriate signature.
* Call the caller function for the mixin pointer.

For multicasts there is a for loop for the last four steps.

[endsect]

[endsect]

[endsect]
