[section:tutorials Tutorials]

[section:quickstart Quickstart]

To make use of the most basic features of Boost.Mixin, you need to create an
object add some mixins to it and then call some messages.

[section:create_object Creating an object]

Creating an object is pretty straightforward. You can just instantiate a
`boost::mixin::object` as you would any other class:

    boost::mixin::object a;
    boost::mixin::object* b = new boost::mixin::object;

Both `a` and `b` will be plain empty objects.

[endsect]

[section:add_mixin Adding mixins to an object]

To add mixins to an object, you first need to have some mixin classes. Any class
can be turned into a mixin with the following two macros.

* `BOOST_DECLARE_MIXIN(someclass)` -- declares that `someclass` is a mixin type.
The best place for this macro is in some header. The header needs to be included
in places where this mixin is mentioned. Such a place would be where we add the
mixin to an object.
* `BOOST_DEFINE_MIXIN(someclass, features)` -- defines the mixin type. Place this
macro in a compiled unit (like a .cpp file). The features of a mixin are an
ampersand separated list of the mixin's specific characteristics. There are
various possible features for a mixin type, but for now we'll focus on the
messages. If a mixin has no features you should use `boost::mixin::none`

So, lets see how we can define a mixin that gives a name to our object.

/named_mixin.hpp/

    #pragma once

    BOOST_DECLARE_MIXIN(named);

/named.hpp/

    #pragma once

    class named
    {
    public:
        const std::string& name() const;
        void set_name(const std::string& new_name);

    private:
        std::string _name;
    };

/named.cpp/

    #include "named_mixin.hpp"
    #include "named.hpp"

    using namespace std;
    using namespace boost::mixin;

    const string& named::name() const
    {
        return _name;
    }

    void named::set_name(const string& new_name)
    {
        _name = new_name;
    }

    BOOST_DEFINE_MIXIN(named, none);

That's it. Now we can add the `named` mixin to an object of ours.

The simplest way of adding mixins to object is with the `mutate` class. If we
include `named_mixin.hpp` somewhere in our code, we could write this:

    using namespace boost::mixin;
    object obj;
    mutate(obj).add<named>();

And now the object `obj` has a mixin of type `named` in it.

[endsect]

[section:add_message Adding and calling messages]

Using the code from above we could get an objects name like this:

    const string& n = obj.get<named>().name();

This is not very useful, because not only do we have to include `named.hpp`, but
we also have to be sure (or at least check) that the object has a mixin of type
`named`. Here's where the messages come into play.

Using messages, you would be able to write code like this:

    set_name(obj, "John");
    const string& n = name(obj);

First we have to declare what messages are there. There are macros to declare
and define messages. For these particular ones, the could would be:

/naming_messages.hpp/

    BOOST_MIXIN_MESSAGE_1(void, set_name, const std::string&, name);
    BOOST_MIXIN_CONST_MESSAGE_0(const std::string&, name);

/naming_messages.cpp/

    BOOST_MIXIN_DEFINE_MESSAGE(set_name);
    BOOST_MIXIN_DEFINE_MESSAGE(name);

The second step would be to tell Boost.Mixin that the `named` mixin implements
those messages. This is done by modifying the second argument of the macro
`BOOST_DEFINE_MIXIN`. (Remember that in that line `none` means that the mixin
has no features).

We need to first include `naming_messages.hpp` and then change the line to be:

    BOOST_DEFINE_MIXIN(named, set_name_msg & name_msg);

and now, after including `naming_messages.hpp` in our other source file, we can
safely use the code from above.

Notice how the feature names are the same as the message names, but suffixed
with `_msg`. This is the suffix for message features. When referring to the
message as a mixin feature, you should always add this suffix, or you'll get
a compilation error. Another place, where it's used, for example, is when
checking whether an object implements a feature:

    obj.implements(name_msg) // will return true, since o has the `named` mixin

The macros, used to create messages we met here are:

* `BOOST_MIXIN_<CONST>_MESSAGE_{arity}(return_value, message_name, arg_type, arg_name...)`
-- declares a message. You should add this macro to header files that declare
messages and should be included whenever the message is mentioned or used.
The optional part `CONST` will make the message work with
`const boost::mixin::object*` and refer to const methods in the mixin class. The
part `{arity}` is a number that shows how many arguments the message takes, and
the message should have a list of `{arity}` pairs of argument type and argument
as macro parameters.
* `BOOST_MIXIN_DEFINE_MESSAGE(message_name)` -- defines the message. It works
for messages of all types and arities. Should be added in some compiled unit
(like a .cpp file). Usually a dedicated compiled unit for each message group is
appropriate in order to avoid needless include dependencies.

[endsect]

[endsect]

[section:mutation Object mutations]
[endsect]

[section:multicast Multicast messages]
[endsect]

[section:priority Adding priorities to messages]
[endsect]

[section:overloading Overloading messages]
[endsect]

[section:mutation_rules Mutation rules]
[endsect]

[section:combinators Multicast combinators]
[endsect]

[section:allocators Using custom allocators]
[endsect]

[section:domain Using different domains]
[endsect]

[section:dynlib Dynamic libraries and program plugins]
[endsect]

[section:tips_tricks Tips and tricks]

* When adding the same set of messages to multiple mixins, create a define of
them all. Like: `#define transform_messages set_position_msg & set_orientation_msg`.
Then use it like this `BOOST_DEFINE_MIXIN(x, some_messages & transform_messages);`
* Instead of using the long message declaration macros, consider defining your
own. Maybe something like `#define BM_C_MSG_1 BOOST_MIXIN_CONST_MESSAGE_1`
* Prefer using `object_type_template`-s instead of mutating each new object.
* Prefer using `same_type_mutator` when mutating multiple objects of the same
type.

[section:common_mixin_parent Mixins with a common parent]
[endsect]

[endsect]

[section:common_problems Common problems and solutions]
[endsect]

[endsect]