[/
 Copyright (c) 2013 Borislav Stanimirov, Zahary Karadjov

 Distributed under the Boost Software License, Version 1.0.
 See accompanying file LICENSE_1_0.txt or copy at
 http:#www.boost.org/LICENSE_1_0.txt
/]

[section:introduction Introduction]

[section:abstract Abstract]

Boost.Mixin is a library that allows the composition and modifications of types
at run time. Types and objects are constructed out of building blocks called
mixins enabling an effect similar to multiple inheritance, while allowing the
client code to remain oblivious to the actual composition of the objects.

A take on the
[@http://en.wikipedia.org/wiki/Composition_over_inheritance Composition over inheritance]
technique, the result closely resembles the popular pattern
[link boost_mixin.appendix.app_ecs entity-component-system],
or the
[@http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_modules.html mixins in Ruby].
It can also be compared to the
[@http://archive.eiffel.com/doc/online/eiffel50/intro/language/tutorial-10.html inheritance in Eiffel]
or the traits in
[@http://selflanguage.org/_static/tutorial/Language/Prototypes/Organizing.html Self],
[@http://www.scala-lang.org/node/126 Scala],
[@http://php.net/manual/en/language.oop5.traits.php PHP],
[@https://en.wikipedia.org/wiki/Trait_(computer_programming) and many others],
or the [@http://doc.perl6.org/language/objects#Roles roles in Perl].

This is given while also having full abstraction between the interface and the
definition of types -- a problem often given as the motivation for the
[@http://www.drdobbs.com/cpp/making-pimpl-easy/205918714 PIMPL idiom].

The library uses the type `boost::mixin::object` as a placeholder, whose
instances can be extended with existing classes (mixins), thus providing
a particular instance with the functionality of all those types. Accessing the
newly formed type's interface is made through messages -- stand-alone functions
generated by the library, which can be thought of as methods.

Boost.Mixin focuses on maximal perofmance and minimal memory overhead.

[endsect]

[section:features List of features]

* Compose types from mixins at run time
* Physically separate interface and implementation
* Non-intrusive -- mixins don't need to have a common parent or any special code
inside
* Mutate "live" objects by changing their composition at run time
* Have multicast messages, which are handled by many mixins within an object
* Possiblity to have custom allocators to finely tune the memory and aim for
cache-locality for critical parts of the code
* Ability to have dynamic libraries that can enrich or modify objects, without
modifying (even rebuilding) the executable.
* Thread safe message calls - as thread safe as the underlying methods.

[endsect]

[section:compare Comparisons]

[section:bm_as_multi_inh Comparison with multiple inheritance]

The closest thing to Boost.Miixin that C++ can offer out of the box is multiple
inheritance. A `boost::mixin::object` composed of some mixins, can be though of
as an empty class that's derived from these classes -- the object's interface
will be equal to the union of the interfaces of its mixins, and it will
internally instantiate them.

We covered how much more than multiple inheritance the library is in the
previous section, but in case you haven't inferred everything, here a
comprehensive list of the most imporatnt differences between Boost.Mixin and C++
multiple inheritance:

* *No combinatorial explosion of types*: you compose types at runtime, and
don't need to explicitly list all possible combination of building-block types.
* *No type-bound interfaces*: since the interface is physically separated from
the implementation (or type), you don't need to have a single class implement
an interface. You could separate it between multiple classes or combine
interfaces in a single class.
* *Live object mutation*: change the interface and/or implementation of messages
in an object at runtime.

However, even-though compared to other libraries that have
similar features, Boost.Mixin is one of the fastest and with the least memory
overhead, using the library comes with some inevitable downsides when compared
with plain multiple inheritance:

* *No compile-time type*: An object derived from, say, `foo` and `bar` can
implicitly be cast too `foo` or `bar`. Since the library uses a placeholder type
-- `boost::mixin::object` -- implicit casts to any of its mixins are impossible.
That aside, the hypothetical object from above, will recieve all of the methods
from foo and bar, but while this is true for the `mixin::object` with such
mixins, a compilation error cannot be generated if a message is called that the
object can't handle. A runtime error will be generated instead, which is the
norm in similar libraries, but is harder to catch and debug than it is with
plain multiple inheritance.
* *Memory overhead per type*: Each unique combination of mixins is internally
represented by a type, which has type metadata -- for example an internal
alternative to a virtual table. The type metadata can take up to two kilobytes
of memory. Unless a type is instantiated its metadata won't be created, but
still if you expect to have a huge variety of types, you may want to keep this
in mind. Of course systems that are expected to have thousands of different
object types, usually wouldn't care about a couple of extra megabytes of memory,
but it could happen.
* *Memory overhead per object*: An instance of an empty class that has multiple
parents takes up memory equal to the sizes of all of its parents. This is
inevitable. A `boost::mixin::objects` naturally takes up the same amount plus an
additional pointer for the type metadata, plus N pointers used for the special
`bm_this` pointer, where N is equal to the number of mixins within. So, in
short, the memory overhead of an object composed on N mixins, is N+1 times
`sizeof(intptr_t)` ((N+1) * 8 bytes on a 64 bit system).
* *Speed of message calls*: A message call is slower than a regular non-virtual
method call. Exactly how much is very hard to estimate, since this depends very
much on cache locality, but a message call can easily be compared to a
`std::function` call in terms of speed, which in most (but not all) cases is
a negligible overhead.

[endsect]

[section:bm_as_an_ecs Boost.Mixin as an entity-component-system]

If you're familiar with entitny-component-systems, one way of looking at at the
library is as if it is one of those, and indeed, it has many features that are
characteristic for such systems.

If you're not familiar with entity-component-systems, you might want to check
out the [link boost_mixin.appendix.app_ecs appendix entry] on them.

Here's how Boost.Mixin is like an ECS:

* `boost::mixin::object` can be interpreted as an entity in an ECS. It's just an
empty class, that needs to be "built" from mixins.
* consequently mixins can be thought of as components. You use mixins to build
objects just as you use components to build entities.
* As with any ECS, you can mutate objects by adding/removing/substituting
mixins.

However, Boost.Mixin is not strictly an ECS. Here's a list of the differences.

* It is non-intrusive: Mixins don't need to inherit from a common parent, nor do
you need to change the code of a class to "turn it into" a mixin.
* Instead of classes with pure virtual methods, messages are used to represent
the functional interface of mixins, and through that -- of objects.
* Because of the previous two differences, `boost::mixin::object`-s can be (and
are) completely oblivious to what kinds of mixins there may be, allowing you
to truly, physically separate a program's subsystems. The entity in an ECS on
the other hand, usually has at least some knowledge of all the possible
component types (like the top level parent classes, for example).
* Some entity-component-systems allow serveral entities to point to the same
instance of a component. This is not possible in Boost.Mixin. A mixin instance
is bound to an object instance

[endsect]

[section:bm_as_ruby_mixin Comparison with Ruby mixins]

[endsect]

[section:bm_as_trait Comparison with traits]

[endsect]

[endsect]

[endsect]
