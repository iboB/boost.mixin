<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Tutorials</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Mixin 0.1">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.Mixin 0.1">
<link rel="prev" href="glossary.html" title="Glossary">
<link rel="next" href="examples.html" title="Examples">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="glossary.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="examples.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost_mixin.tutorials"></a><a class="link" href="tutorials.html" title="Tutorials">Tutorials</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="tutorials.html#boost_mixin.tutorials.messages">Messages</a></span></dt>
<dt><span class="section"><a href="tutorials.html#boost_mixin.tutorials.mutation">Object mutation</a></span></dt>
<dt><span class="section"><a href="tutorials.html#boost_mixin.tutorials.combinators">Multicast result combinators</a></span></dt>
<dt><span class="section"><a href="tutorials.html#boost_mixin.tutorials.tips_tricks">Tips and tricks</a></span></dt>
<dt><span class="section"><a href="tutorials.html#boost_mixin.tutorials.common_problems">Common problems
      and solutions</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.tutorials.messages"></a><a class="link" href="tutorials.html#boost_mixin.tutorials.messages" title="Messages">Messages</a>
</h3></div></div></div>
<p>
        <a class="indexterm" name="idp34450000"></a>
      </p>
<p>
        (For the complete, working source of this example see <a href="https://github.com/iboB/boost.mixin/blob/master/libs/mixin/tutorial/messages.cpp" target="_top">messages.cpp</a>)
      </p>
<p>
        For this tutorial will look a simplified piece of code from an imaginary
        game. First let's define the mixin classes that we're going to use.
      </p>
<p>
        There's a mixin that's a part from evey object of our game. The one that
        gives them a unique id. We'll also define a method, called <code class="computeroutput"><span class="identifier">trace</span></code> that will display information about
        the mixin in a stream.
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">has_id</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">set_id</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">id</span><span class="special">)</span> <span class="special">{</span> <span class="identifier">_id</span> <span class="special">=</span> <span class="identifier">id</span><span class="special">;</span> <span class="special">}</span>
    <span class="keyword">int</span> <span class="identifier">id</span><span class="special">()</span> <span class="keyword">const</span> <span class="special">{</span> <span class="keyword">return</span> <span class="identifier">_id</span><span class="special">;</span> <span class="special">}</span>

    <span class="keyword">void</span> <span class="identifier">trace</span><span class="special">(</span><span class="identifier">ostream</span><span class="special">&amp;</span> <span class="identifier">out</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="keyword">int</span> <span class="identifier">_id</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<p>
        Next we'll define a class for an animated model. We could have other types
        of models in the game, but for this tutorial there's no need to define anything
        more.
      </p>
<p>
        The mixin offers us a way to set a mesh and two ways to set an animation.
        It has a render method and, again the trace method, to display info about
        this mixin.
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">animated_model</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">set_mesh</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">string</span><span class="special">&amp;</span> <span class="identifier">mesh</span><span class="special">);</span>

    <span class="keyword">void</span> <span class="identifier">set_animation</span><span class="special">(</span><span class="keyword">const</span> <span class="identifier">string</span><span class="special">&amp;</span> <span class="identifier">animation</span><span class="special">);</span>
    <span class="keyword">void</span> <span class="identifier">set_animation</span><span class="special">(</span><span class="keyword">int</span> <span class="identifier">anim_id</span><span class="special">);</span>

    <span class="keyword">void</span> <span class="identifier">render</span><span class="special">()</span> <span class="keyword">const</span><span class="special">;</span>

    <span class="keyword">void</span> <span class="identifier">trace</span><span class="special">(</span><span class="identifier">ostream</span><span class="special">&amp;</span> <span class="identifier">out</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>

<span class="keyword">private</span><span class="special">:</span>
    <span class="identifier">string</span> <span class="identifier">_mesh</span><span class="special">;</span>
    <span class="identifier">string</span> <span class="identifier">_animation</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<p>
        Now we'll define three types of mixins that will give us artificial intelligence
        logic for different occasions. They all share a method called <code class="computeroutput"><span class="identifier">think</span></code> for the AI, and the familiar trace
        method.
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">enemy_ai</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">think</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">trace</span><span class="special">(</span><span class="identifier">ostream</span><span class="special">&amp;</span> <span class="identifier">out</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">class</span> <span class="identifier">ally_ai</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">think</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">trace</span><span class="special">(</span><span class="identifier">ostream</span><span class="special">&amp;</span> <span class="identifier">out</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>

<span class="keyword">class</span> <span class="identifier">stunned_ai</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">think</span><span class="special">();</span>

    <span class="keyword">void</span> <span class="identifier">trace</span><span class="special">(</span><span class="identifier">ostream</span><span class="special">&amp;</span> <span class="identifier">out</span><span class="special">)</span> <span class="keyword">const</span><span class="special">;</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<p>
        Now it's time to declare the messages our mixins will use. We have some methods
        in our classes for which there won't be any messages, since those methods
        aren't polymoriphic. They're unique for their specific classes so it's absolutely
        adequate to call them by <code class="computeroutput"><span class="identifier">object</span><span class="special">.</span><span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">mixin</span><span class="special">&gt;()-&gt;</span><span class="identifier">method</span><span class="special">(...)</span></code>.
      </p>
<p>
        So, let's start with the simplest case. The one we alreay used in the <a class="link" href="basic.html" title="Basic usage">basic usage example</a>.
      </p>
<p>
        The declaration syntax is the familiar macro <code class="computeroutput"><span class="identifier">BOOST_MIXIN_MESSAGE_</span><span class="special">|</span><span class="identifier">N</span><span class="special">|</span></code>,
        where <code class="computeroutput"><span class="special">|</span><span class="identifier">N</span><span class="special">|</span></code> stands for the number of arguments the message
        has. The macro's aruments are coma separated: return value, message/method
        name, argument 1 type, argument 1 name, argument 2 type, argument 2 name,
        etc etc.
      </p>
<p>
        This simple case is covered by the messages <code class="computeroutput"><span class="identifier">think</span></code>
        and <code class="computeroutput"><span class="identifier">set_mesh</span></code> <sup>[<a name="boost_mixin.tutorials.messages.f0" href="#ftn.boost_mixin.tutorials.messages.f0" class="footnote">1</a>]</sup>
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">BOOST_MIXIN_MESSAGE_0</span><span class="special">(</span><span class="keyword">void</span><span class="special">,</span> <span class="identifier">think</span><span class="special">);</span>
<span class="identifier">BOOST_MIXIN_MESSAGE_1</span><span class="special">(</span><span class="keyword">void</span><span class="special">,</span> <span class="identifier">set_mesh</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">string</span><span class="special">&amp;,</span> <span class="identifier">mesh</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        Now it may seem that <code class="computeroutput"><span class="identifier">render</span></code>
        is also a pretty simple example of a message, but there's a small difference.
        It's supposed to be handled by const methods. This makes it a const message
        and as such it has a different declaration macro &#8211; the same as before
        but with <code class="computeroutput"><span class="identifier">CONST</span></code> added to it:
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">BOOST_MIXIN_CONST_MESSAGE_0</span><span class="special">(</span><span class="keyword">void</span><span class="special">,</span> <span class="identifier">render</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        Lets see the <code class="computeroutput"><span class="identifier">trace</span></code> method,
        that's presen in all of our classes. If we declare a message for it in the
        way we talked above, only of the mixins within an object will be able to
        handle it. But when we <code class="computeroutput"><span class="identifier">trace</span></code>
        an object's info, we obviously would like to have the info for all of its
        mixins. For cases like this: where more than one of the mixins in an object
        is supposed to handle a message, Boost.Mixin introduces <span class="emphasis"><em>multicast</em></span>
        messages. You declare those by adding <code class="computeroutput"><span class="identifier">MULTICAST</span></code>
        to the macro (before <code class="computeroutput"><span class="identifier">MESSAGE</span></code>
        but after <code class="computeroutput"><span class="identifier">CONST</span></code> if it's a
        const one)
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">BOOST_MIXIN_CONST_MULTICAST_MESSAGE_1</span><span class="special">(</span><span class="keyword">void</span><span class="special">,</span> <span class="identifier">trace</span><span class="special">,</span> <span class="identifier">ostream</span><span class="special">&amp;,</span> <span class="identifier">out</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        The last type of message there is meant for overloaded methods. For these
        we need message overloads.
      </p>
<p>
        A message overload will require you to think of a special name, that's used
        to refer to that message, different from the name of the method. Don't worry
        though the stand-alone function that's generated for the message call itself
        will have the appropriate name (the method's name).
      </p>
<p>
        The macro used for message overloads is the same as before with <code class="computeroutput"><span class="identifier">OVERLOAD</span></code> at the end. The other difference
        is that its first argument should be the custom name for the message (followed
        by the type, method name, and method/message arguments like before).
      </p>
<p>
        In our case <code class="computeroutput"><span class="identifier">set_animation</span></code>
        has two overloads:
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">BOOST_MIXIN_MESSAGE_1_OVERLOAD</span><span class="special">(</span><span class="identifier">set_anim_by_name</span><span class="special">,</span> <span class="keyword">void</span><span class="special">,</span> <span class="identifier">set_animation</span><span class="special">,</span> <span class="keyword">const</span> <span class="identifier">string</span><span class="special">&amp;,</span> <span class="identifier">animation</span><span class="special">);</span>
<span class="identifier">BOOST_MIXIN_MESSAGE_1_OVERLOAD</span><span class="special">(</span><span class="identifier">set_anim_by_id</span><span class="special">,</span> <span class="keyword">void</span><span class="special">,</span> <span class="identifier">set_animation</span><span class="special">,</span> <span class="keyword">int</span><span class="special">,</span> <span class="identifier">anim_id</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        As you might have guessed, any message could be defined as a message overload
        and indeed in the case where there are no overloads <code class="computeroutput"><span class="identifier">BOOST_MIXIN_MESSAGE_N</span><span class="special">(</span><span class="identifier">ret</span><span class="special">,</span>
        <span class="identifier">message_name</span><span class="special">,</span>
        <span class="special">...)</span></code> will just expand to <code class="computeroutput"><span class="identifier">BOOST_MIXIN_MESSAGE_N_OVERLOAD</span><span class="special">(</span><span class="identifier">message_name</span><span class="special">,</span>
        <span class="identifier">ret</span><span class="special">,</span>
        <span class="identifier">message_name</span><span class="special">,</span>
        <span class="special">...)</span></code>
      </p>
<p>
        So, now that we've declared all our messages it's time to define them.
      </p>
<p>
        The macro used for defining a message is always the same, regardless of the
        message's constness, mechanism (multicast/unicast), or overload. It has a
        single argument &#8211; the message's name.
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">BOOST_MIXIN_DEFINE_MESSAGE</span><span class="special">(</span><span class="identifier">think</span><span class="special">);</span>
<span class="identifier">BOOST_MIXIN_DEFINE_MESSAGE</span><span class="special">(</span><span class="identifier">set_mesh</span><span class="special">);</span>
<span class="identifier">BOOST_MIXIN_DEFINE_MESSAGE</span><span class="special">(</span><span class="identifier">render</span><span class="special">);</span>
<span class="identifier">BOOST_MIXIN_DEFINE_MESSAGE</span><span class="special">(</span><span class="identifier">trace</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        For the overloads we should use our custom name:
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">BOOST_MIXIN_DEFINE_MESSAGE</span><span class="special">(</span><span class="identifier">set_anim_by_name</span><span class="special">);</span>
<span class="identifier">BOOST_MIXIN_DEFINE_MESSAGE</span><span class="special">(</span><span class="identifier">set_anim_by_id</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        Great! Now that we have our messages it's time to define the classes from
        above as mixins.
      </p>
<p>
        Normally if the our program is spread across several files, you should use
        <code class="computeroutput"><span class="identifier">BOOST_DECLARE_MIXIN</span></code> to declare
        that those classes are mixins, but since our program is in a single file,
        it can be omitted. All of its functionality is also encompassed by <code class="computeroutput"><span class="identifier">BOOST_DEFINE_MIXIN</span></code>.
      </p>
<p>
        We met the <code class="computeroutput"><span class="identifier">BOOST_DEFINE_MIXIN</span></code>
        macro from the basic example. It has two arguments &#8211; the mixin/class
        name and it's feature list. The feature list is a ampersand separated list
        symbols that represent the mixin's features and can contain many things but
        for now we'll focus on messages &#8211; the ones this mixin is supposed
        to handle.
      </p>
<p>
        The special thing here, is that in order to distinguish the stand-alone function
        that's generated to make message calls from the message, the library defines
        a special symbol for each message. This symbol is used in the mixin feature
        list and when checking whether a mixin implements a message. The symbol is
        the message postfixed with <code class="computeroutput"><span class="identifier">_msg</span></code>.
      </p>
<p>
        Let's define three of our simple mixins along with their feature (message)
        lists:
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">BOOST_DEFINE_MIXIN</span><span class="special">(</span><span class="identifier">enemy_ai</span><span class="special">,</span> <span class="identifier">think_msg</span> <span class="special">&amp;</span> <span class="identifier">trace_msg</span><span class="special">);</span>
<span class="identifier">BOOST_DEFINE_MIXIN</span><span class="special">(</span><span class="identifier">ally_ai</span><span class="special">,</span> <span class="identifier">think_msg</span> <span class="special">&amp;</span> <span class="identifier">trace_msg</span><span class="special">);</span>
<span class="identifier">BOOST_DEFINE_MIXIN</span><span class="special">(</span><span class="identifier">animated_model</span><span class="special">,</span>
    <span class="identifier">trace_msg</span> <span class="special">&amp;</span> <span class="identifier">set_mesh_msg</span> <span class="special">&amp;</span> <span class="identifier">set_anim_by_id_msg</span> <span class="special">&amp;</span> <span class="identifier">set_anim_by_name_msg</span> <span class="special">&amp;</span> <span class="identifier">render_msg</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        The reason we left out <code class="computeroutput"><span class="identifier">has_id</span></code>
        and <code class="computeroutput"><span class="identifier">stunned_ai</span></code> is because
        we'd like to do something special with their message lists.
      </p>
<p>
        <a class="indexterm" name="idp34667152"></a>
      </p>
<p>
        First, about <code class="computeroutput"><span class="identifier">has_id</span></code>. What
        we'd like to do is display its info first, because the object id is usually
        the first thing you need about an object. So in otder to achieve this the
        notion of message priority is introduced. Each message in a mixin gets a
        priority of 0 by default. For multicast messages like <code class="computeroutput"><span class="identifier">trace</span></code>
        the priority will affect the order in which they're executed. The higher
        priority a multicast message has in a mixin, the earlier it will be executed.
        So if we set the priority of <code class="computeroutput"><span class="identifier">trace</span></code>
        in <code class="computeroutput"><span class="identifier">has_id</span></code> to something greater
        than zero, we'll have a guarantee that when the object info is displayed
        its id will come first.
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">BOOST_DEFINE_MIXIN</span><span class="special">(</span><span class="identifier">has_id</span><span class="special">,</span> <span class="identifier">priority</span><span class="special">(</span><span class="number">1</span><span class="special">,</span> <span class="identifier">trace_msg</span><span class="special">));</span>
</pre>
<p>
      </p>
<p>
        For unicast messages the priority determines which of the potentially many
        mixin candidates will handle the message. Again mixins with higher priority
        for a message are considered better candidates.
      </p>
<p>
        So if we set the priority of <code class="computeroutput"><span class="identifier">think</span></code>
        in <code class="computeroutput"><span class="identifier">stunned_ai</span></code> to something
        greater than zero, then adding this mixin to an object that already has a
        think message (like objects with <code class="computeroutput"><span class="identifier">enemy_ai</span></code>
        or <code class="computeroutput"><span class="identifier">ally_ai</span></code>) will hide it
        previous implementation and override it with the one from <code class="computeroutput"><span class="identifier">stunned_ai</span></code>.
        If we remove the mixin, the previous implementation will be exposed and will
        resume handling the <code class="computeroutput"><span class="identifier">think</span></code>
        calls.
      </p>
<p>
        Also we'll consider <code class="computeroutput"><span class="identifier">stunned_ai</span></code>
        as a relatively uninteresting mixin, and set the priority of <code class="computeroutput"><span class="identifier">trace</span></code> to -1, and make its info be displayed
        last (if at all available)
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">BOOST_DEFINE_MIXIN</span><span class="special">(</span><span class="identifier">stunned_ai</span><span class="special">,</span> <span class="identifier">priority</span><span class="special">(</span><span class="number">1</span><span class="special">,</span> <span class="identifier">think_msg</span><span class="special">)</span> <span class="special">&amp;</span> <span class="identifier">priority</span><span class="special">(-</span><span class="number">1</span><span class="special">,</span> <span class="identifier">trace_msg</span><span class="special">));</span>
</pre>
<p>
      </p>
<p>
        We're now ready to start using our mixins and messages in the simplified
        game.
      </p>
<p>
        Let's start by creating two objects - an enemy and an ally to the hypothetical
        main character. We'll give them some irrelevant id-s and meshes.
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">object</span> <span class="identifier">enemy</span><span class="special">;</span> <span class="comment">// just an empty boost::mixin::object</span>

<span class="identifier">mutate</span><span class="special">(</span><span class="identifier">enemy</span><span class="special">)</span>
    <span class="special">.</span><span class="identifier">add</span><span class="special">&lt;</span><span class="identifier">has_id</span><span class="special">&gt;()</span>
    <span class="special">.</span><span class="identifier">add</span><span class="special">&lt;</span><span class="identifier">animated_model</span><span class="special">&gt;()</span>
    <span class="special">.</span><span class="identifier">add</span><span class="special">&lt;</span><span class="identifier">enemy_ai</span><span class="special">&gt;();</span>

<span class="identifier">enemy</span><span class="special">.</span><span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">has_id</span><span class="special">&gt;()-&gt;</span><span class="identifier">set_id</span><span class="special">(</span><span class="number">1</span><span class="special">);</span>
<span class="identifier">set_mesh</span><span class="special">(</span><span class="identifier">enemy</span><span class="special">,</span> <span class="string">"spider.mesh"</span><span class="special">);</span>

<span class="identifier">trace</span><span class="special">(</span><span class="identifier">enemy</span><span class="special">,</span> <span class="identifier">cout</span><span class="special">);</span> <span class="comment">// trace enemy data</span>

<span class="identifier">object</span> <span class="identifier">ally</span><span class="special">;</span>

<span class="identifier">mutate</span><span class="special">(</span><span class="identifier">ally</span><span class="special">)</span>
    <span class="special">.</span><span class="identifier">add</span><span class="special">&lt;</span><span class="identifier">has_id</span><span class="special">&gt;()</span>
    <span class="special">.</span><span class="identifier">add</span><span class="special">&lt;</span><span class="identifier">animated_model</span><span class="special">&gt;()</span>
    <span class="special">.</span><span class="identifier">add</span><span class="special">&lt;</span><span class="identifier">ally_ai</span><span class="special">&gt;();</span>

<span class="identifier">ally</span><span class="special">.</span><span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">has_id</span><span class="special">&gt;()-&gt;</span><span class="identifier">set_id</span><span class="special">(</span><span class="number">5</span><span class="special">);</span>
<span class="identifier">set_mesh</span><span class="special">(</span><span class="identifier">ally</span><span class="special">,</span> <span class="string">"dog.mesh"</span><span class="special">);</span>

<span class="identifier">trace</span><span class="special">(</span><span class="identifier">ally</span><span class="special">,</span> <span class="identifier">cout</span><span class="special">);</span> <span class="comment">// trace ally data</span>
</pre>
<p>
      </p>
<p>
        Both calls to <code class="computeroutput"><span class="identifier">trace</span></code> from
        above will display info about the newly constructed objects in the console.
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">think</span><span class="special">(</span><span class="identifier">enemy</span><span class="special">);</span> <span class="comment">// doing enemy stuff</span>
<span class="identifier">think</span><span class="special">(</span><span class="identifier">ally</span><span class="special">);</span> <span class="comment">// doing friendly stuff</span>

<span class="identifier">render</span><span class="special">(</span><span class="identifier">enemy</span><span class="special">);</span> <span class="comment">// drawing a hostile enemy</span>
<span class="identifier">render</span><span class="special">(</span><span class="identifier">ally</span><span class="special">);</span> <span class="comment">// drawing a friendly ally</span>
</pre>
<p>
      </p>
<p>
        Now lets try stunning our enemy. We'll just add the <code class="computeroutput"><span class="identifier">stunned_ai</span></code>
        mixin and, because of its special <code class="computeroutput"><span class="identifier">think</span></code>
        priority, the calls to <code class="computeroutput"><span class="identifier">think</span></code>
        from then on will be handled by it.
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">mutate</span><span class="special">(</span><span class="identifier">enemy</span><span class="special">).</span><span class="identifier">add</span><span class="special">&lt;</span><span class="identifier">stunned_ai</span><span class="special">&gt;();</span>
<span class="identifier">think</span><span class="special">(</span><span class="identifier">enemy</span><span class="special">);</span> <span class="comment">// don't do hostile stuff, because you're stunned</span>
<span class="identifier">render</span><span class="special">(</span><span class="identifier">enemy</span><span class="special">);</span> <span class="comment">// drawing a stunned enemy</span>
</pre>
<p>
      </p>
<p>
        Now let's remove the stun effect from our enemy, by simply removing the
        <code class="computeroutput"><span class="identifier">stunned_ai</span></code> mixin from the
        object. The handling of <code class="computeroutput"><span class="identifier">think</span></code>
        by <code class="computeroutput"><span class="identifier">enemy_ai</span></code> will resume as
        before.
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">mutate</span><span class="special">(</span><span class="identifier">enemy</span><span class="special">).</span><span class="identifier">remove</span><span class="special">&lt;</span><span class="identifier">stunned_ai</span><span class="special">&gt;();</span>
<span class="identifier">think</span><span class="special">(</span><span class="identifier">enemy</span><span class="special">);</span> <span class="comment">// again do hostile stuff</span>
<span class="identifier">render</span><span class="special">(</span><span class="identifier">enemy</span><span class="special">);</span> <span class="comment">// drawing a hostile enemy</span>
</pre>
<p>
      </p>
<p>
        And that concludes our tutorial on messages.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.tutorials.mutation"></a><a class="link" href="tutorials.html#boost_mixin.tutorials.mutation" title="Object mutation">Object mutation</a>
</h3></div></div></div>
<p>
        <a class="indexterm" name="idp34793136"></a>
      </p>
<p>
        (For the complete, working source of this example see <a href="https://github.com/iboB/boost.mixin/blob/master/libs/mixin/tutorial/mutation.cpp" target="_top">mutation.cpp</a>)
      </p>
<p>
        For this tutorial let's begin by introducing some mixins that may be found
        in a game: A root mixin, that should be present in all objects, and two that
        provide a way to render the object on the screen:
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">game_object</span>
<span class="special">{</span>
    <span class="keyword">int</span> <span class="identifier">_id</span><span class="special">;</span>
    <span class="identifier">string</span> <span class="identifier">name</span><span class="special">;</span>
    <span class="comment">// ... other common fields</span>
<span class="special">};</span>

<span class="keyword">class</span> <span class="identifier">opengl_rendering</span>
<span class="special">{</span>
<span class="special">};</span>

<span class="keyword">class</span> <span class="identifier">directx_rendering</span>
<span class="special">{</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<p>
        We won't concert ourselves with their concrete functionality, so we'll just
        leave them with no messages.
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">BOOST_DEFINE_MIXIN</span><span class="special">(</span><span class="identifier">game_object</span><span class="special">,</span> <span class="identifier">none</span><span class="special">);</span>
<span class="identifier">BOOST_DEFINE_MIXIN</span><span class="special">(</span><span class="identifier">opengl_rendering</span><span class="special">,</span> <span class="identifier">none</span><span class="special">);</span>
<span class="identifier">BOOST_DEFINE_MIXIN</span><span class="special">(</span><span class="identifier">directx_rendering</span><span class="special">,</span> <span class="identifier">none</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        You're probably familiar from the previous examples with the most basic way
        to mutate an object, so let's use it to give it a type.
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">object</span> <span class="identifier">obj1</span><span class="special">;</span>
<span class="identifier">mutate</span><span class="special">(</span><span class="identifier">obj1</span><span class="special">)</span>
    <span class="special">.</span><span class="identifier">add</span><span class="special">&lt;</span><span class="identifier">game_object</span><span class="special">&gt;()</span>
    <span class="special">.</span><span class="identifier">add</span><span class="special">&lt;</span><span class="identifier">opengl_rendering</span><span class="special">&gt;();</span>
</pre>
<p>
      </p>
<p>
        ...and then change it. Let's assume we're switching our rendering platform.
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">mutate</span><span class="special">(</span><span class="identifier">obj1</span><span class="special">)</span>
    <span class="special">.</span><span class="identifier">remove</span><span class="special">&lt;</span><span class="identifier">opengl_rendering</span><span class="special">&gt;()</span>
    <span class="special">.</span><span class="identifier">add</span><span class="special">&lt;</span><span class="identifier">directx_rendering</span><span class="special">&gt;();</span>
</pre>
<p>
      </p>
<p>
        Using the <code class="computeroutput"><span class="identifier">mutate</span></code> class is
        probably the most common way in which you'll mutate objects in Boost.Mixin.
        Yes, <code class="computeroutput"><span class="identifier">mutate</span></code> is not a function
        but a class, that has methods <code class="computeroutput"><span class="identifier">remove</span></code>
        and <code class="computeroutput"><span class="identifier">add</span></code>, and in its destructor
        it applies the actual mutation.
      </p>
<p>
        A mutation is a relatively slow process so if the internal object type was
        being changed on each call of <code class="computeroutput"><span class="identifier">remove</span></code>
        or <code class="computeroutput"><span class="identifier">add</span></code>, first the program
        would be needlessly slowed down, and second the library would need to deal
        with various incomplete types in its internal type registry.
      </p>
<p>
        So, if you want to add and remove mixins accross several blocks or functions,
        you may safely instantiate the <code class="computeroutput"><span class="identifier">mutate</span></code>
        class or use its typedef <code class="computeroutput"><span class="identifier">single_object_mutator</span></code>
        that probably has a more appropriate name for cases like this.
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">single_object_mutator</span> <span class="identifier">mutation</span><span class="special">(</span><span class="identifier">obj1</span><span class="special">);</span>

<span class="identifier">mutation</span><span class="special">.</span><span class="identifier">remove</span><span class="special">&lt;</span><span class="identifier">directx_rendering</span><span class="special">&gt;();</span>
<span class="comment">// ...</span>
<span class="identifier">mutation</span><span class="special">.</span><span class="identifier">add</span><span class="special">&lt;</span><span class="identifier">opengl_rendering</span><span class="special">&gt;();</span>
</pre>
<p>
      </p>
<p>
        Here <code class="computeroutput"><span class="identifier">obj1</span></code> hasn't been mutated
        yet. A type that has <code class="computeroutput"><span class="identifier">game_object</span></code>
        and <code class="computeroutput"><span class="identifier">opengl_rendering</span></code> hasn't
        been instantiated internally. In order for this to happen the <code class="computeroutput"><span class="identifier">mutation</span></code> instance needs to be destroyed,
        or, to explicitly perform the mutation, you may call <code class="computeroutput"><span class="identifier">apply</span></code>
        like so:
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">mutation</span><span class="special">.</span><span class="identifier">apply</span><span class="special">();</span>
</pre>
<p>
      </p>
<p>
        Now <code class="computeroutput"><span class="identifier">obj1</span></code> has been mutated,
        and <code class="computeroutput"><span class="identifier">mutation</span></code> has been "cleared"
        &#8211; returned to the empty state it had right after its instantiation.
        This means we can reuse it to perform other mutation on <code class="computeroutput"><span class="identifier">obj1</span></code>.
        Say:
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">mutation</span><span class="special">.</span><span class="identifier">remove</span><span class="special">&lt;</span><span class="identifier">game_object</span><span class="special">&gt;();</span>
</pre>
<p>
      </p>
<p>
        Oops! We're removing the mixin that needs to be present in all objects. Not
        to worry. You may "clear" a mutation without applying it, by calling
        <code class="computeroutput"><span class="identifier">cancel</span></code>.
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">mutation</span><span class="special">.</span><span class="identifier">cancel</span><span class="special">();</span>
</pre>
<p>
      </p>
<p>
        Now the mutation is not performed, and its state is empty.
      </p>
<p>
        You may safely apply empty mutations to an object:
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">mutation</span><span class="special">.</span><span class="identifier">apply</span><span class="special">();</span> <span class="comment">// no effect</span>
</pre>
<p>
      </p>
<p>
        Another way to mutate objects is by using a type template.
      </p>
<p>
        A type template gives a type to an object and, unlike <code class="computeroutput"><span class="identifier">mutate</span><span class="special">/</span><span class="identifier">single_object_mutator</span></code>
        it's not bound to a specific object instance. Again unlike <code class="computeroutput"><span class="identifier">mutate</span></code> it disregards all mixins within
        an object and applies its internal type, hence it has no <code class="computeroutput"><span class="identifier">remove</span></code>
        method. It implicitly "removes" all mixins that are not among its
        own.
      </p>
<p>
        You can create a type template like so:
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">object_type_template</span> <span class="identifier">directx_rendering_template</span><span class="special">;</span>
<span class="identifier">directx_rendering_template</span>
    <span class="special">.</span><span class="identifier">add</span><span class="special">&lt;</span><span class="identifier">game_object</span><span class="special">&gt;()</span>
    <span class="special">.</span><span class="identifier">add</span><span class="special">&lt;</span><span class="identifier">directx_rendering</span><span class="special">&gt;()</span>
    <span class="special">.</span><span class="identifier">create</span><span class="special">();</span>
</pre>
<p>
      </p>
<p>
        Again, similar to the case with <code class="computeroutput"><span class="identifier">single_object_mutator</span></code>,
        you can spread these calls among many blocks or functions.
      </p>
<p>
        Don't forget to call <code class="computeroutput"><span class="identifier">create</span></code>.
        It is the method that creates the internal object type. If you try to apply
        a type template that hasn't been created to an object, a runtime error will
        be triggered.
      </p>
<p>
        To apply a type template to an object you may pass it as a parameter to its
        constructor.
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">object</span> <span class="identifier">obj2</span><span class="special">(</span><span class="identifier">directx_rendering_template</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        Now <code class="computeroutput"><span class="identifier">obj2</span></code> has the mixins
        <code class="computeroutput"><span class="identifier">game_object</span></code> and <code class="computeroutput"><span class="identifier">directx_rendering</span></code>.
      </p>
<p>
        Let's create a new type template.
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">object_type_template</span> <span class="identifier">opengl_rendering_template</span><span class="special">;</span>
<span class="identifier">opengl_rendering_template</span>
    <span class="special">.</span><span class="identifier">add</span><span class="special">&lt;</span><span class="identifier">game_object</span><span class="special">&gt;()</span>
    <span class="special">.</span><span class="identifier">add</span><span class="special">&lt;</span><span class="identifier">opengl_rendering</span><span class="special">&gt;()</span>
    <span class="special">.</span><span class="identifier">create</span><span class="special">();</span>
</pre>
<p>
      </p>
<p>
        ...to illustrate the other way of applying it to an object:
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">opengl_rendering_template</span><span class="special">.</span><span class="identifier">apply_to</span><span class="special">(</span><span class="identifier">obj2</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        Applying this type template it the same object, was equivalent to <code class="computeroutput"><span class="identifier">mutate</span></code>-ing it, removing <code class="computeroutput"><span class="identifier">directx_rendering</span></code>
        and adding <code class="computeroutput"><span class="identifier">opengl_rendering</span></code>.
      </p>
<p>
        Now we have two objects &#8211; <code class="computeroutput"><span class="identifier">obj1</span></code>
        and <code class="computeroutput"><span class="identifier">obj2</span></code> &#8211; that have
        the same mixins.
      </p>
<p>
        Sometimes the case would be such that you have a big group of objects that
        have the exact same type internally, and want them all to be mutated to have
        a different type. Naturally you may <code class="computeroutput"><span class="identifier">mutate</span></code>
        each of them one by one, and this would be the appropriate (and only) way
        to mutate a group of objects that have a <span class="emphasis"><em>different</em></span> type.
      </p>
<p>
        If the type is the same, however, you have a slightly faster alternative.
        The same type mutator:
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">same_type_mutator</span> <span class="identifier">directx</span><span class="special">;</span>
<span class="identifier">directx</span>
    <span class="special">.</span><span class="identifier">remove</span><span class="special">&lt;</span><span class="identifier">opengl_rendering</span><span class="special">&gt;()</span>
    <span class="special">.</span><span class="identifier">add</span><span class="special">&lt;</span><span class="identifier">directx_rendering</span><span class="special">&gt;();</span>
</pre>
<p>
      </p>
<p>
        Unlike type templates, same type mutators don't need you to create them explicitly
        with some method. The creation of the internal type and all preparations
        are done when the mutation is applied to the first object.
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">directx</span><span class="special">.</span><span class="identifier">apply_to</span><span class="special">(</span><span class="identifier">obj1</span><span class="special">);</span>
<span class="identifier">directx</span><span class="special">.</span><span class="identifier">apply_to</span><span class="special">(</span><span class="identifier">obj2</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        Remember that the only time you can afford to use a same type mutator, is
        when <span class="emphasis"><em>all</em></span> objects that need to be mutated with it have
        composed of the same set of mixins.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.tutorials.mutation.mrules"></a><a class="link" href="tutorials.html#boost_mixin.tutorials.mutation.mrules" title="Mutation rules">Mutation rules</a>
</h4></div></div></div>
<p>
          <a class="indexterm" name="idp34953168"></a>
        </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.tutorials.combinators"></a><a class="link" href="tutorials.html#boost_mixin.tutorials.combinators" title="Multicast result combinators">Multicast result combinators</a>
</h3></div></div></div>
<p>
        <a class="indexterm" name="idp34956064"></a>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.tutorials.tips_tricks"></a><a class="link" href="tutorials.html#boost_mixin.tutorials.tips_tricks" title="Tips and tricks">Tips and tricks</a>
</h3></div></div></div>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            When adding the same set of messages to multiple mixins, create a define
            of them all. Like: <code class="computeroutput"><span class="preprocessor">#define</span>
            <span class="identifier">transform_messages</span> <span class="identifier">set_position_msg</span>
            <span class="special">&amp;</span> <span class="identifier">set_orientation_msg</span></code>.
            Then use it like this <code class="computeroutput"><span class="identifier">BOOST_DEFINE_MIXIN</span><span class="special">(</span><span class="identifier">x</span><span class="special">,</span> <span class="identifier">some_messages</span>
            <span class="special">&amp;</span> <span class="identifier">transform_messages</span><span class="special">);</span></code>
          </li>
<li class="listitem">
            Instead of using the long message declaration macros, consider defining
            your own. Maybe something like <code class="computeroutput"><span class="preprocessor">#define</span>
            <span class="identifier">BM_C_MSG_1</span> <span class="identifier">BOOST_MIXIN_CONST_MESSAGE_1</span></code>
          </li>
<li class="listitem">
            Prefer using <code class="computeroutput"><span class="identifier">object_type_template</span></code>-s
            instead of mutating each new object in the same fashion.
          </li>
<li class="listitem">
            Prefer using <code class="computeroutput"><span class="identifier">same_type_mutator</span></code>
            when mutating multiple objects of the same type.
          </li>
<li class="listitem">
            If you have some messages that are valid for <span class="emphasis"><em>all</em></span>
            objects in your system, instead of adding them to a mixin present in
            every object, consider having some stand-alone functions where your first
            parameter is <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">object</span><span class="special">&amp;</span></code>.
            They will be indistinguishable from messages.
          </li>
<li class="listitem">
            If you have multicast logic that needs to stop after a success in any
            of the message implementations in an object, have your messages return
            <code class="computeroutput"><span class="keyword">bool</span></code> and then use the <code class="computeroutput"><span class="identifier">boolean_or</span></code> combinator. It will stop
            the message execution on the first <code class="computeroutput"><span class="keyword">true</span></code>.
          </li>
</ul></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.tutorials.tips_tricks.common_mixin_parent"></a><a class="link" href="tutorials.html#boost_mixin.tutorials.tips_tricks.common_mixin_parent" title="Mixins with a common parent">Mixins
        with a common parent</a>
</h4></div></div></div>
<p>
          Sometimes you will feel the need to have mixins with a common parent. Most
          likely this will happen when you want to define two different mixins that
          share some common functionality. Moving the shared functionality in the
          same common parent is a good idea and Boost.Mixin will work exactly the
          same way if you do this. However there is a pitfall in this case. It happens
          when you have multiple inheritance. Due to the special nature in which
          the libray arranges the memory internally if a mixin type has more than
          one parent using <code class="computeroutput"><span class="identifier">bm_this</span></code>
          in one of those parents might lead to crashes.
        </p>
<p>
          More precisely, when the library allocates memory for a mixin type it allocates
          a buffer that is slightly bigger than needed and puts the pointer to the
          owning object at its front. What <code class="computeroutput"><span class="identifier">bm_this</span></code>
          does is actually an offset from <code class="computeroutput"><span class="keyword">this</span></code>
          with the appropriate number of bytes for <code class="computeroutput"><span class="identifier">object</span><span class="special">*</span></code>. So if a parent of your mixin type, other
          than the first calls <code class="computeroutput"><span class="identifier">bm_this</span></code>
          it will end up returning an invalid pointer to the owning object.
        </p>
<p>
          To be able to have parents, other than the first, with access to the owning
          object we suggest that you create a pure virtual function that gets it
          from the actual mixin type.
        </p>
<p>
          Say <code class="computeroutput"><span class="keyword">virtual</span> <span class="identifier">object</span><span class="special">*</span> <span class="identifier">get_bm_object</span><span class="special">()</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span></code> in the parents, which is implemented in
          the child class (the actual mixin defined with <code class="computeroutput"><span class="identifier">BOOST_DEFINE_MIXIN</span></code>)
          by simply <code class="computeroutput"><span class="keyword">return</span> <span class="identifier">bm_this</span></code>.
        </p>
<p>
          Of course there are other ways to accomplish this, for example with CRTP,
          but the virtual function is probably the cleanest and safest one.
        </p>
</div>
</div>
<div class="section"><div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.tutorials.common_problems"></a><a class="link" href="tutorials.html#boost_mixin.tutorials.common_problems" title="Common problems and solutions">Common problems
      and solutions</a>
</h3></div></div></div></div>
<div class="footnotes">
<br><hr width="100" align="left">
<div class="footnote"><p><sup>[<a id="ftn.boost_mixin.tutorials.messages.f0" href="#boost_mixin.tutorials.messages.f0" class="para">1</a>] </sup>
          Although set_mesh is a message that can be handled by a single class in
          our example, in an actual product there would be other types of "model"
          mixins, which would make it polymorphic. That's why we're making it a message
          instead of a method to be called by <code class="computeroutput"><span class="identifier">object</span><span class="special">.</span><span class="identifier">get</span><span class="special">&lt;</span><span class="identifier">animated_model</span><span class="special">&gt;()-&gt;</span><span class="identifier">set_mesh</span><span class="special">(</span><span class="identifier">somemesh</span><span class="special">)</span></code>
        </p></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2013, 2014 Borislav Stanimirov, Zahary Karadjov<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>).
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="glossary.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="examples.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
