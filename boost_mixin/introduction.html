<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Introduction</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Mixin 0.1">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.Mixin 0.1">
<link rel="prev" href="../index.html" title="Chapter&#160;1.&#160;Boost.Mixin 0.1">
<link rel="next" href="basic.html" title="Basic usage">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="basic.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost_mixin.introduction"></a><a class="link" href="introduction.html" title="Introduction">Introduction</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="introduction.html#boost_mixin.introduction.abstract">Abstract</a></span></dt>
<dt><span class="section"><a href="introduction.html#boost_mixin.introduction.features">List of features</a></span></dt>
<dt><span class="section"><a href="introduction.html#boost_mixin.introduction.whentouse">When (and when not)
      to use Boost.Mixin</a></span></dt>
<dt><span class="section"><a href="introduction.html#boost_mixin.introduction.compare">Comparisons</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.introduction.abstract"></a><a class="link" href="introduction.html#boost_mixin.introduction.abstract" title="Abstract">Abstract</a>
</h3></div></div></div>
<p>
        Boost.Mixin is a library that allows the composition and modifications of
        polymorphic types at run time. Types and objects are constructed out of building
        blocks called mixins enabling an effect similar to multiple inheritance,
        while allowing the client code to remain oblivious to the actual composition
        of the objects.
      </p>
<p>
        A take on the <a href="http://en.wikipedia.org/wiki/Composition_over_inheritance" target="_top">Composition
        over inheritance</a> technique, the result closely resembles the popular
        pattern <a class="link" href="appendix.html#boost_mixin.appendix.app_ecs" title="Appendix A. Entity-component-systems">entity-component-system</a>,
        or the <a href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_modules.html" target="_top">mixins
        in Ruby</a>. It can also be compared to the <a href="http://archive.eiffel.com/doc/online/eiffel50/intro/language/tutorial-10.html" target="_top">inheritance
        in Eiffel</a> or the traits in <a href="http://selflanguage.org/_static/tutorial/Language/Prototypes/Organizing.html" target="_top">Self</a>,
        <a href="http://www.scala-lang.org/node/126" target="_top">Scala</a>, <a href="http://php.net/manual/en/language.oop5.traits.php" target="_top">PHP</a>,
        <a href="https://en.wikipedia.org/wiki/Trait_(computer_programming)" target="_top">and
        many others</a>, or the <a href="http://doc.perl6.org/language/objects#Roles" target="_top">roles
        in Perl</a>.
      </p>
<p>
        This is given while also having full abstraction between the interface and
        the definition of types &#8211; a problem often given as the motivation
        for the <a href="http://www.drdobbs.com/cpp/making-pimpl-easy/205918714" target="_top">PIMPL
        idiom</a>.
      </p>
<p>
        In short, <span class="emphasis"><em>Boost.Mixin is an alternative way to accomplish polymorphism</em></span>.
      </p>
<p>
        The library uses the type <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">object</span></code>
        as a placeholder, whose instances can be extended with existing classes (mixins),
        thus providing a particular instance with the functionality of all those
        types. Accessing the newly formed type's interface is made through messages
        &#8211; stand-alone functions generated by the library, which can be thought
        of as methods.
      </p>
<p>
        Boost.Mixin focuses on maximal performance and minimal memory overhead.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.introduction.abstract.other_mixin"></a><a class="link" href="introduction.html#boost_mixin.introduction.abstract.other_mixin" title='Other meanings of "mixin" in C++'>Other
        meanings of "mixin" in C++</a>
</h4></div></div></div>
<p>
          The name "Mixin" is not to be confused with another meaning,
          popular in C++, namely <a href="http://en.wikipedia.org/wiki/Curiously_recurring_template_pattern" target="_top">CRTP
          mixins</a>. This particular use of CRTP in this document shall henceforth
          be referred to as "traits", as the exact same functionality is
          called "traits" in many other languages.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.introduction.abstract.other_mixin_D"></a><a class="link" href="introduction.html#boost_mixin.introduction.abstract.other_mixin_D" title='Other meanings of "mixin" in other languages'>Other
        meanings of "mixin" in other languages</a>
</h4></div></div></div>
<div class="itemizedlist"><ul class="itemizedlist" type="disc"><li class="listitem">
              In D <a href="http://dlang.org/mixin.html" target="_top">the term mixin</a>
              exists and <code class="computeroutput"><span class="identifier">mixin</span></code> is
              a keyword. It is a compile time feature, that has some similarities
              with the macros in C and C++, and none at all with Boost.Mixin. It
              is a completely different concept.
            </li></ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.introduction.abstract.feel"></a><a class="link" href="introduction.html#boost_mixin.introduction.abstract.feel" title="Basic look and feel of the code with Boost.Mixin">Basic look
        and feel of the code with Boost.Mixin</a>
</h4></div></div></div>
<p>
          Here is a very small and incomplete example of what your code may look
          like if you use the library.
        </p>
<pre class="programlisting"><span class="comment">// assuming my_objects.get_ally(0); is a way to get an ally to the</span>
<span class="comment">// main character in a game</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">object</span><span class="special">&amp;</span> <span class="identifier">obj</span> <span class="special">=</span> <span class="identifier">my_objects</span><span class="special">.</span><span class="identifier">get_ally</span><span class="special">(</span><span class="number">0</span><span class="special">);</span>

<span class="comment">// now let's make the object think some positive thoughts about the</span>
<span class="comment">// main character</span>

<span class="identifier">think</span><span class="special">(</span><span class="identifier">obj</span><span class="special">);</span> <span class="comment">// C++ doesn't allow us to have obj.think().</span>
            <span class="comment">// Boost.Mixin's messages are standalone functions</span>

<span class="comment">// type composition</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">mutate</span><span class="special">(</span><span class="identifier">obj</span><span class="special">)</span>
    <span class="special">.</span><span class="identifier">add</span><span class="special">&lt;</span><span class="identifier">flying_creature</span><span class="special">&gt;();</span>

<span class="comment">// object can now respond to fly()</span>

<span class="identifier">fly</span><span class="special">(</span><span class="identifier">obj</span><span class="special">);</span> <span class="comment">// ...instead of obj.fly()</span>

<span class="comment">// type mutation</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">mutate</span><span class="special">(</span><span class="identifier">obj</span><span class="special">)</span>
    <span class="special">.</span><span class="identifier">remove</span><span class="special">&lt;</span><span class="identifier">ally</span><span class="special">&gt;()</span>
    <span class="special">.</span><span class="identifier">add</span><span class="special">&lt;</span><span class="identifier">enemy</span><span class="special">&gt;();</span>

<span class="identifier">think</span><span class="special">(</span><span class="identifier">obj</span><span class="special">);</span> <span class="comment">// the same object now thinks negative thoughts about the main</span>
            <span class="comment">// character, since it's no longer an ally, but an enemy</span>
</pre>
<p>
          For a more detailed, working example see <a class="link" href="basic.html" title="Basic usage">Basic
          usage</a>.
        </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.introduction.features"></a><a class="link" href="introduction.html#boost_mixin.introduction.features" title="List of features">List of features</a>
</h3></div></div></div>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            Compose types from mixins at run time
          </li>
<li class="listitem">
            Physically separate interface and implementation
          </li>
<li class="listitem">
            Non-intrusive &#8211; mixins don't need to have a common parent or any
            special code inside
          </li>
<li class="listitem">
            Mutate "live" objects by changing their composition at run
            time
          </li>
<li class="listitem">
            Have multicast messages, which are handled by many mixins within an object
          </li>
<li class="listitem">
            Possibility to have custom allocators to finely tune the memory and aim
            for cache-locality for critical parts of the code
          </li>
<li class="listitem">
            Ability to have dynamic libraries that can enrich or modify objects,
            without modifying (even rebuilding) the executable.
          </li>
<li class="listitem">
            Thread safe message calls - as thread safe as the underlying methods.
          </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.introduction.whentouse"></a><a class="link" href="introduction.html#boost_mixin.introduction.whentouse" title="When (and when not) to use Boost.Mixin">When (and when not)
      to use Boost.Mixin</a>
</h3></div></div></div>
<p>
        The more complex your objects are, the more beneficial it will be to use
        the library. Pieces of software that typically have very complex objects
        include Games (especially role-playing ones or strategies), CAD systems,
        enterprise systems, UI libraries, and more.
      </p>
<p>
        As a general rule of thumb: if you have complex polymorphic objects, Boost.Mixin
        is a good choice.
      </p>
<p>
        We should emphasize on the polymorphism. In many very high-performance systems
        polymorphism is avoided, at the cost of code that is (at least somewhat)
        harder to write and maintain (this is most often the case with high-end games).
        Since such systems will try to "squeeze" every possible piece of
        processing power out of the CPU, cache locality and lack of cache misses
        are critical in some parts of their code. As is the case with all instances
        of polymorphism, including C++ virtual methods and <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span></code>,
        uses of Boost.Mixin's features will almost certainly lead to cache misses.
        Of course, you may still rely on the library in other parts of your code.
        For more information about the library performance, see the <a class="link" href="advanced.html#boost_mixin.advanced.performance" title="Performance">Performance
        section</a>.
      </p>
<p>
        Of course, small projects with simple objects, even if they are polymorphic,
        may end up not finding any particular benefits in using the library, since
        their size makes them fast to compile and easy to maintain as they are. If
        a piece of software can be created in a couple of days, by one or two programmers,
        there will hardly be any need for Boost.Mixin.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.introduction.compare"></a><a class="link" href="introduction.html#boost_mixin.introduction.compare" title="Comparisons">Comparisons</a>
</h3></div></div></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.introduction.compare.bm_as_multi_inh"></a><a class="link" href="introduction.html#boost_mixin.introduction.compare.bm_as_multi_inh" title="Comparison with multiple inheritance">Comparison
        with multiple inheritance</a>
</h4></div></div></div>
<p>
          The closest thing to Boost.Miixin that C++ can offer out of the box is
          multiple inheritance. A <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">object</span></code>
          composed of some mixins, can be though of as an empty class that's derived
          from these classes &#8211; the object's interface will be equal to the
          union of the interfaces of its mixins, and it will internally instantiate
          them.
        </p>
<p>
          We covered how much more than multiple inheritance the library is in the
          previous section, but in case you haven't inferred everything, here a comprehensive
          list of the most important differences between Boost.Mixin and C++ multiple
          inheritance:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              <span class="bold"><strong>No combinatorial explosion of types</strong></span>:
              you compose types at runtime, and don't need to explicitly list all
              possible combination of building-block types.
            </li>
<li class="listitem">
              <span class="bold"><strong>No type-bound interfaces</strong></span>: since the
              interface is physically separated from the implementation (or type),
              you don't need to have a single class implement an interface. You could
              separate it between multiple classes or combine interfaces in a single
              class.
            </li>
<li class="listitem">
              <span class="bold"><strong>Live object mutation</strong></span>: change the interface
              and/or implementation of messages in an object at runtime.
            </li>
<li class="listitem">
              <span class="bold"><strong>Natural common reference</strong></span>: in order
              to have containers of your objects composed by multiple inheritance,
              you need to define a "master type" from which all parents
              need to be derived by virtual inheritance. Such a type would be a coupling
              "focal point" and would need to be frequently changed while
              you develop your software. In Boost.Mixin this is a no-issue, since
              all objects in the library are of type <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">object</span></code>.
            </li>
</ul></div>
<p>
          However, even-though compared to other libraries that have similar features,
          Boost.Mixin is one of the fastest and with the least memory overhead, using
          the library comes with some inevitable downsides when compared with plain
          multiple inheritance:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              <span class="bold"><strong>No compile-time type</strong></span>: An object derived
              from, say, <code class="computeroutput"><span class="identifier">foo</span></code> and
              <code class="computeroutput"><span class="identifier">bar</span></code> can implicitly
              be cast too <code class="computeroutput"><span class="identifier">foo</span></code> or
              <code class="computeroutput"><span class="identifier">bar</span></code>. Since the library
              uses a placeholder type &#8211; <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">object</span></code>
              &#8211; implicit casts to any of its mixins are impossible. That aside,
              the hypothetical object from above, will receive all of the methods
              from foo and bar, but while this is true for the <code class="computeroutput"><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">object</span></code>
              with such mixins, a compilation error cannot be generated if a message
              is called that the object can't handle. A runtime error will be generated
              instead, which is the norm in similar libraries, but is harder to catch
              and debug than it is with plain multiple inheritance.
            </li>
<li class="listitem">
              <span class="bold"><strong>Memory overhead per type</strong></span>: Each unique
              combination of mixins is internally represented by a type, which has
              type metadata &#8211; for example an internal alternative to a virtual
              table. The type metadata can take up to two kilobytes of memory. Unless
              a type is instantiated its metadata won't be created, but still if
              you expect to have a huge variety of types, you may want to keep this
              in mind. Of course systems that are expected to have thousands of different
              object types, usually wouldn't care about a couple of extra megabytes
              of memory, but it could happen.
            </li>
<li class="listitem">
              <span class="bold"><strong>Memory overhead per object</strong></span>: An instance
              of an empty class that has multiple parents takes up memory equal to
              the sizes of all of its parents. This is inevitable. A <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">objects</span></code> naturally takes up the same
              amount plus an additional pointer for the type metadata, plus N pointers
              used for the special <code class="computeroutput"><span class="identifier">bm_this</span></code>
              pointer, where N is equal to the number of mixins within. So, in short,
              the memory overhead of an object composed on N mixins, is N+1 times
              <code class="computeroutput"><span class="keyword">sizeof</span><span class="special">(</span><span class="identifier">intptr_t</span><span class="special">)</span></code>
              ((N+1) * 8 bytes on a 64 bit system).
            </li>
<li class="listitem">
              <span class="bold"><strong>Speed of message calls</strong></span>: A message
              call is slower than a regular non-virtual method call. Exactly how
              much is very hard to estimate, since this depends very much on cache
              locality, but a message call can easily be compared to a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span></code> call in terms of speed,
              which in most (but not all) cases is a negligible overhead.
            </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.introduction.compare.bm_as_an_ecs"></a><a class="link" href="introduction.html#boost_mixin.introduction.compare.bm_as_an_ecs" title="Boost.Mixin as an entity-component-system">Boost.Mixin
        as an entity-component-system</a>
</h4></div></div></div>
<p>
          If you're familiar with entity-component-systems, one way of looking at
          at the library is as if it is one of those, and indeed, it has many features
          that are characteristic for such systems.
        </p>
<p>
          If you're not familiar with entity-component-systems, you might want to
          check out the <a class="link" href="appendix.html#boost_mixin.appendix.app_ecs" title="Appendix A. Entity-component-systems">appendix entry</a>
          on them.
        </p>
<p>
          Here's how Boost.Mixin is like an ECS:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">object</span></code> can be interpreted as an entity
              in an ECS. It's just an empty class, that needs to be "built"
              from mixins.
            </li>
<li class="listitem">
              consequently mixins can be thought of as components. You use mixins
              to build objects just as you use components to build entities.
            </li>
<li class="listitem">
              As with any ECS, you can mutate objects by adding/removing/substituting
              mixins.
            </li>
</ul></div>
<p>
          However, Boost.Mixin is not strictly an ECS. Here's a list of the differences.
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              It is non-intrusive: Mixins don't need to inherit from a common parent,
              nor do you need to change the code of a class to "turn it into"
              a mixin.
            </li>
<li class="listitem">
              Instead of classes with pure virtual methods, messages are used to
              represent the functional interface of mixins, and through that &#8211;
              of objects.
            </li>
<li class="listitem">
              Because of the previous two differences, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">object</span></code>-s
              can be (and are) completely oblivious to what kinds of mixins there
              may be, allowing you to truly, physically separate a program's subsystems.
              The entity in an ECS on the other hand, usually has at least some knowledge
              of all the possible component types (like the top level parent classes,
              for example).
            </li>
<li class="listitem">
              Some entity-component-systems allow several entities to point to the
              same instance of a component. This is not possible in Boost.Mixin.
              A mixin instance is bound to an object instance
            </li>
</ul></div>
<p>
          Note that some data structures, sometimes called entity-component-systems,
          are not used to create and manage polymorphic objects, but instead are
          used to bind a strictly predefined set of concrete components to the same
          entity for a very performance intensive piece of software. The components
          are used by different subsystems, that require them to be aligned in dense
          arrays for faster processing, without cache misses. As we mentioned before,
          Boost.Mixin isn't designed for such cases, and while in terms of design
          and ease of use, it is a better choice than such an approach, it cannot
          help you in their main goal.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.introduction.compare.bm_as_trait"></a><a class="link" href="introduction.html#boost_mixin.introduction.compare.bm_as_trait" title="Comparison with traits">Comparison
        with traits</a>
</h4></div></div></div>
<p>
          As mentioned above Boost.Mixin is similar to a feature of many other languages,
          called "traits". The exact same feature can be mimicked in C++
          with CRTP. You may have heard the term "mixin" being mentioned
          in a C++ context before. It is very likely that what was meant was this
          CRTP style of creating types from existing ones.
        </p>
<p>
          Indeed, at least superficially, both Boost.Mixin and said traits are very
          similar as both are used to create new types by combining existing ones,
          while also solving one of the problems of plain old multiple inheritance
          - the communication between the different components that comprise the
          object.
        </p>
<p>
          However much of the multiple inheritance problems remain:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              Types composed of traits are static. Most languages (including C++
              using the aforementioned mimic) don't allow you to change an object's
              type.
            </li>
<li class="listitem">
              There is still a combinatorial explosion of types: each possible combination
              needs to be explicitly coded.
            </li>
<li class="listitem">
              In strongly typed languages, like C++, there is still the problem of
              having a common interface to all objects.
            </li>
<li class="listitem">
              In C++ you are bound to having the same compilation dependencies because
              of the header files that need to be included to compose types.
            </li>
</ul></div>
<p>
          Boost.Mixin solves all of these problems.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.introduction.compare.bm_as_ruby_mixin"></a><a class="link" href="introduction.html#boost_mixin.introduction.compare.bm_as_ruby_mixin" title="Comparison with Ruby mixins">Comparison
        with Ruby mixins</a>
</h4></div></div></div>
<p>
          If you're familiar with the <a href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_modules.html" target="_top">mixins
          in Ruby</a>, perhaps you will find a lot of similarities between them
          and Boost.Mixin.
        </p>
<p>
          Ruby's mixins can of course be used just like traits, however extending
          existing objects with modules is also allowed via <code class="computeroutput"><span class="identifier">Object</span><span class="preprocessor">#extend</span></code>. This is almost exactly what
          Boost.Mixin allows you to do. Indeed, Ruby has been a great inspiration
          for this library.
        </p>
<p>
          Still, barring the differences that arise from C++ being a strongly typed
          language, for a small amount of extra code Boost.Mixin allows you to do
          much more:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              <span class="bold"><strong>Removing mixins</strong></span>: in Ruby, when you
              extend an object with a module, all functions that both object and
              the module have are permanently overridden in the object by their versions
              from the module. Boost.Mixin allows you to temporarily mutate the object
              and then remove the mixin while restoring the object exactly to its
              former self.
            </li>
<li class="listitem">
              <span class="bold"><strong>Prioritize messages</strong></span>: in Boost.Mixin
              you can set priorities to the messages and thus when extending an object
              with a mixin, if a message is implemented by the object with a higher
              priority, even though it is also supplied by the mixin, in won't override
              the one already in the object.
            </li>
<li class="listitem">
              <span class="bold"><strong>Multicast messages</strong></span>: in Ruby (as in
              almost every other language with a similar functionality) a method
              call leads to a piece of code, defined for that method. Boost.Mixin
              allows you to have messages that are handled by more than one of mixins
              in an object.
            </li>
</ul></div>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2013, 2014 Borislav Stanimirov, Zahary Karadjov<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>).
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="basic.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
