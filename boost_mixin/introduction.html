<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Introduction</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Mixin 0.1">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.Mixin 0.1">
<link rel="prev" href="../index.html" title="Chapter&#160;1.&#160;Boost.Mixin 0.1">
<link rel="next" href="basic.html" title="Basic usage">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="basic.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost_mixin.introduction"></a><a class="link" href="introduction.html" title="Introduction">Introduction</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="introduction.html#boost_mixin.introduction.abstract">Abstract</a></span></dt>
<dt><span class="section"><a href="introduction.html#boost_mixin.introduction.features">List of features</a></span></dt>
<dt><span class="section"><a href="introduction.html#boost_mixin.introduction.compare">Comparisons</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.introduction.abstract"></a><a class="link" href="introduction.html#boost_mixin.introduction.abstract" title="Abstract">Abstract</a>
</h3></div></div></div>
<p>
        Boost.Mixin is a library that allows the composition and modifications of
        types at run time. Types and objects are constructed out of building blocks
        called mixins enabling an effect similar to multiple inheritance, while allowing
        the client code to remain oblivious to the actual composition of the objects.
      </p>
<p>
        A take on the <a href="http://en.wikipedia.org/wiki/Composition_over_inheritance" target="_top">Composition
        over inheritance</a> technique, the result closely resembles the popular
        pattern <a class="link" href="appendix.html#boost_mixin.appendix.app_ecs" title="Appendix A. Entity-component-systems">entity-component-system</a>,
        or the <a href="http://www.ruby-doc.org/docs/ProgrammingRuby/html/tut_modules.html" target="_top">mixins
        in Ruby</a>. It can also be compared to the <a href="http://archive.eiffel.com/doc/online/eiffel50/intro/language/tutorial-10.html" target="_top">inheritance
        in Eiffel</a> or the traits in <a href="http://selflanguage.org/_static/tutorial/Language/Prototypes/Organizing.html" target="_top">Self</a>,
        <a href="http://www.scala-lang.org/node/126" target="_top">Scala</a>, <a href="http://php.net/manual/en/language.oop5.traits.php" target="_top">PHP</a>,
        <a href="https://en.wikipedia.org/wiki/Trait_(computer_programming)" target="_top">and
        many others</a>, or the <a href="http://doc.perl6.org/language/objects#Roles" target="_top">roles
        in Perl</a>.
      </p>
<p>
        This is given while also having full abstraction between the interface and
        the definition of types &#8211; a problem often given as the motivation
        for the <a href="http://www.drdobbs.com/cpp/making-pimpl-easy/205918714" target="_top">PIMPL
        idiom</a>.
      </p>
<p>
        The library uses the type <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">object</span></code>
        as a placeholder, whose instances can be extended with existing classes (mixins),
        thus providing a particular instance with the functionality of all those
        types. Accessing the newly formed type's interface is made through messages
        &#8211; stand-alone functions generated by the library, which can be thought
        of as methods.
      </p>
<p>
        Boost.Mixin focuses on maximal performance and minimal memory overhead.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.introduction.features"></a><a class="link" href="introduction.html#boost_mixin.introduction.features" title="List of features">List of features</a>
</h3></div></div></div>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
            Compose types from mixins at run time
          </li>
<li class="listitem">
            Physically separate interface and implementation
          </li>
<li class="listitem">
            Non-intrusive &#8211; mixins don't need to have a common parent or any
            special code inside
          </li>
<li class="listitem">
            Mutate "live" objects by changing their composition at run
            time
          </li>
<li class="listitem">
            Have multicast messages, which are handled by many mixins within an object
          </li>
<li class="listitem">
            Possiblity to have custom allocators to finely tune the memory and aim
            for cache-locality for critical parts of the code
          </li>
<li class="listitem">
            Ability to have dynamic libraries that can enrich or modify objects,
            without modifying (even rebuilding) the executable.
          </li>
<li class="listitem">
            Thread safe message calls - as thread safe as the underlying methods.
          </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.introduction.compare"></a><a class="link" href="introduction.html#boost_mixin.introduction.compare" title="Comparisons">Comparisons</a>
</h3></div></div></div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.introduction.compare.bm_as_multi_inh"></a><a class="link" href="introduction.html#boost_mixin.introduction.compare.bm_as_multi_inh" title="Comparison with multiple inheritance">Comparison
        with multiple inheritance</a>
</h4></div></div></div>
<p>
          The closest thing to Boost.Miixin that C++ can offer out of the box is
          multiple inheritance. A <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">object</span></code>
          composed of some mixins, can be though of as an empty class that's derived
          from these classes &#8211; the object's interface will be equal to the
          union of the interfaces of its mixins, and it will internally instantiate
          them.
        </p>
<p>
          We covered how much more than multiple inheritance the library is in the
          previous section, but in case you haven't inferred everything, here a comprehensive
          list of the most imporatnt differences between Boost.Mixin and C++ multiple
          inheritance:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              <span class="bold"><strong>No combinatorial explosion of types</strong></span>:
              you compose types at runtime, and don't need to explicitly list all
              possible combination of building-block types.
            </li>
<li class="listitem">
              <span class="bold"><strong>No type-bound interfaces</strong></span>: since the
              interface is physically separated from the implementation (or type),
              you don't need to have a single class implement an interface. You could
              separate it between multiple classes or combine interfaces in a single
              class.
            </li>
<li class="listitem">
              <span class="bold"><strong>Live object mutation</strong></span>: change the interface
              and/or implementation of messages in an object at runtime.
            </li>
</ul></div>
<p>
          However, even-though compared to other libraries that have similar features,
          Boost.Mixin is one of the fastest and with the least memory overhead, using
          the library comes with some inevitable downsides when compared with plain
          multiple inheritance:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              <span class="bold"><strong>No compile-time type</strong></span>: An object derived
              from, say, <code class="computeroutput"><span class="identifier">foo</span></code> and
              <code class="computeroutput"><span class="identifier">bar</span></code> can implicitly
              be cast too <code class="computeroutput"><span class="identifier">foo</span></code> or
              <code class="computeroutput"><span class="identifier">bar</span></code>. Since the library
              uses a placeholder type &#8211; <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">object</span></code>
              &#8211; implicit casts to any of its mixins are impossible. That aside,
              the hypothetical object from above, will recieve all of the methods
              from foo and bar, but while this is true for the <code class="computeroutput"><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">object</span></code>
              with such mixins, a compilation error cannot be generated if a message
              is called that the object can't handle. A runtime error will be generated
              instead, which is the norm in similar libraries, but is harder to catch
              and debug than it is with plain multiple inheritance.
            </li>
<li class="listitem">
              <span class="bold"><strong>Memory overhead per type</strong></span>: Each unique
              combination of mixins is internally represented by a type, which has
              type metadata &#8211; for example an internal alternative to a virtual
              table. The type metadata can take up to two kilobytes of memory. Unless
              a type is instantiated its metadata won't be created, but still if
              you expect to have a huge variety of types, you may want to keep this
              in mind. Of course systems that are expected to have thousands of different
              object types, usually wouldn't care about a couple of extra megabytes
              of memory, but it could happen.
            </li>
<li class="listitem">
              <span class="bold"><strong>Memory overhead per object</strong></span>: An instance
              of an empty class that has multiple parents takes up memory equal to
              the sizes of all of its parents. This is inevitable. A <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">objects</span></code> naturally takes up the same
              amount plus an additional pointer for the type metadata, plus N pointers
              used for the special <code class="computeroutput"><span class="identifier">bm_this</span></code>
              pointer, where N is equal to the number of mixins within. So, in short,
              the memory overhead of an object composed on N mixins, is N+1 times
              <code class="computeroutput"><span class="keyword">sizeof</span><span class="special">(</span><span class="identifier">intptr_t</span><span class="special">)</span></code>
              ((N+1) * 8 bytes on a 64 bit system).
            </li>
<li class="listitem">
              <span class="bold"><strong>Speed of message calls</strong></span>: A message
              call is slower than a regular non-virtual method call. Exactly how
              much is very hard to estimate, since this depends very much on cache
              locality, but a message call can easily be compared to a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span></code> call in terms of speed,
              which in most (but not all) cases is a negligible overhead.
            </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.introduction.compare.bm_as_an_ecs"></a><a class="link" href="introduction.html#boost_mixin.introduction.compare.bm_as_an_ecs" title="Boost.Mixin as an entity-component-system">Boost.Mixin
        as an entity-component-system</a>
</h4></div></div></div>
<p>
          If you're familiar with entity-component-systems, one way of looking at
          at the library is as if it is one of those, and indeed, it has many features
          that are characteristic for such systems.
        </p>
<p>
          If you're not familiar with entity-component-systems, you might want to
          check out the <a class="link" href="appendix.html#boost_mixin.appendix.app_ecs" title="Appendix A. Entity-component-systems">appendix entry</a>
          on them.
        </p>
<p>
          Here's how Boost.Mixin is like an ECS:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">object</span></code> can be interpreted as an entity
              in an ECS. It's just an empty class, that needs to be "built"
              from mixins.
            </li>
<li class="listitem">
              consequently mixins can be thought of as components. You use mixins
              to build objects just as you use components to build entities.
            </li>
<li class="listitem">
              As with any ECS, you can mutate objects by adding/removing/substituting
              mixins.
            </li>
</ul></div>
<p>
          However, Boost.Mixin is not strictly an ECS. Here's a list of the differences.
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              It is non-intrusive: Mixins don't need to inherit from a common parent,
              nor do you need to change the code of a class to "turn it into"
              a mixin.
            </li>
<li class="listitem">
              Instead of classes with pure virtual methods, messages are used to
              represent the functional interface of mixins, and through that &#8211;
              of objects.
            </li>
<li class="listitem">
              Because of the previous two differences, <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">object</span></code>-s
              can be (and are) completely oblivious to what kinds of mixins there
              may be, allowing you to truly, physically separate a program's subsystems.
              The entity in an ECS on the other hand, usually has at least some knowledge
              of all the possible component types (like the top level parent classes,
              for example).
            </li>
<li class="listitem">
              Some entity-component-systems allow serveral entities to point to the
              same instance of a component. This is not possible in Boost.Mixin.
              A mixin instance is bound to an object instance
            </li>
</ul></div>
</div>
<div class="section"><div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.introduction.compare.bm_as_ruby_mixin"></a><a class="link" href="introduction.html#boost_mixin.introduction.compare.bm_as_ruby_mixin" title="Comparison with Ruby mixins">Comparison
        with Ruby mixins</a>
</h4></div></div></div></div>
<div class="section"><div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.introduction.compare.bm_as_trait"></a><a class="link" href="introduction.html#boost_mixin.introduction.compare.bm_as_trait" title="Comparison with traits">Comparison
        with traits</a>
</h4></div></div></div></div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2013 Borislav Stanimirov, Zahary Karadjov<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>).
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="../index.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="basic.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
