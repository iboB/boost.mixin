<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Advanced topics</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Mixin 0.1">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.Mixin 0.1">
<link rel="prev" href="debugging.html" title="Debugging code that uses Boost.Mixin">
<link rel="next" href="../mixin/reference.html" title="Reference">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="debugging.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="../mixin/reference.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost_mixin.advanced"></a><a class="link" href="advanced.html" title="Advanced topics">Advanced topics</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="advanced.html#boost_mixin.advanced.performance">Performance</a></span></dt>
<dt><span class="section"><a href="advanced.html#boost_mixin.advanced.allocators">Using custom allocators</a></span></dt>
<dt><span class="section"><a href="advanced.html#boost_mixin.advanced.arity">Having messages with more
      arguments</a></span></dt>
<dt><span class="section"><a href="advanced.html#boost_mixin.advanced.dynlib">Dynamic libraries and program
      plugins</a></span></dt>
<dt><span class="section"><a href="advanced.html#boost_mixin.advanced.implementation">Implementation notes</a></span></dt>
<dt><span class="section"><a href="advanced.html#boost_mixin.advanced.macros">Macros rationale</a></span></dt>
</dl></div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.advanced.performance"></a><a class="link" href="advanced.html#boost_mixin.advanced.performance" title="Performance">Performance</a>
</h3></div></div></div>
<p>
        <a class="indexterm" name="idp36105520"></a>
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.advanced.performance.msg_perf"></a><a class="link" href="advanced.html#boost_mixin.advanced.performance.msg_perf" title="Message performance">Message
        performance</a>
</h4></div></div></div>
<p>
          <a class="indexterm" name="idp36108544"></a>
        </p>
<p>
          The performance of messages is indeed slower than regular function calls
          and even virtual function calls. Even though a call's algorithmic complexity
          is still O(1), a number of memory indirections happen in order to call
          the actual method behind the message.
        </p>
<p>
          Unfortunately it's hard to estimate exactly how much slower the message
          call is. With perfect cache locality and compiler optimizations a message
          call will take about 15 cycles, compared to about 5-7 cycles for a virtual
          call and 10-12 cycles for a std::function call. 15 cycles on a modern 2.8
          GHz processor take about 5 nanoseconds to execute, which is a negligible
          cost for a call.
        </p>
<p>
          Unfortunately perfect cache locality is hard to come by, and especially
          hard in polymorphic code. In an amortized test with potential cache misses
          for all calls, Boost.Mixin messages take on average about 120 cycles (40
          nanoseconds on the same processor), compared to 90 cycles on average for
          virtual calls and 115 cycles for a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span></code>
          call.
        </p>
<p>
          So, generally speaking if the programmer doesn't take special care to achieve
          cache locality for their object lists, a message call is about 2 times
          slower than a regular method call and about 1.3 times slower than a virtual
          call and about as fast as a <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span></code>
          call, which again can be called negligible.
        </p>
<p>
          As, we've mentioned before if cache locality is an absolutely critical
          feature for the desired performance, mixin messages, virtual calls, <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span></code>, and other types of polymorphism
          will almost certainly be detrimental for this code, and the programmers
          are advised to do something else.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_mixin.advanced.performance.msg_perf.msg_perf_test"></a><a class="link" href="advanced.html#boost_mixin.advanced.performance.msg_perf.msg_perf_test" title="Message performance test">Message
          performance test</a>
</h5></div></div></div>
<p>
            The message performance test compares regular method calls vs virtual
            method calls vs <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span></code> calls vs Boost.Mixin unicast
            message calls.
          </p>
<p>
            It creates 10,000 objects, then processes them until 100,000,000 calls
            are made. The actual calls perform a simple addition whose cost compared
            with the call cost is indeed negligible.
          </p>
<p>
            The regular method calls are what you would have in cache-locality optimized
            setting &#8211; they are methods in an array of objects of the the same
            type stored by value.
          </p>
<p>
            The other calls are polymorphic and their arrays store objects by address
            that can be one of two types.
          </p>
<p>
            Here are some test results:
          </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
                OS: Ubuntu 13.04
              </li>
<li class="listitem">
                CPU: AMD FX X8 8150
              </li>
<li class="listitem">
                Compiler: g++ (Ubuntu/Linaro 4.7.3-1ubuntu1)
              </li>
<li class="listitem">
                Debug compilation parameters: <code class="computeroutput"><span class="special">-</span><span class="identifier">fexceptions</span> <span class="special">-</span><span class="identifier">g</span></code>
              </li>
<li class="listitem">
                Release compilation parameters <code class="computeroutput"><span class="special">-</span><span class="identifier">fexceptions</span> <span class="special">-</span><span class="identifier">O2</span></code>
              </li>
</ul></div>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                    <p>
                      Method
                    </p>
                  </th>
<th>
                    <p>
                      Debug
                    </p>
                  </th>
<th>
                    <p>
                      Debug mean
                    </p>
                  </th>
<th>
                    <p>
                      Release
                    </p>
                  </th>
<th>
                    <p>
                      Release mean
                    </p>
                  </th>
</tr></thead>
<tbody>
<tr>
<td>
                    <p>
                      Regular
                    </p>
                  </td>
<td>
                    <p>
                      2345 ms
                    </p>
                  </td>
<td>
                    <p>
                      23 ns
                    </p>
                  </td>
<td>
                    <p>
                      1088 ms
                    </p>
                  </td>
<td>
                    <p>
                      11 ns
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      Virtual
                    </p>
                  </td>
<td>
                    <p>
                      2894 ms
                    </p>
                  </td>
<td>
                    <p>
                      29 ns
                    </p>
                  </td>
<td>
                    <p>
                      1580 ms
                    </p>
                  </td>
<td>
                    <p>
                      16 ns
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">function</span></code>
                    </p>
                  </td>
<td>
                    <p>
                      11910 ms
                    </p>
                  </td>
<td>
                    <p>
                      119 ns
                    </p>
                  </td>
<td>
                    <p>
                      1966 ms
                    </p>
                  </td>
<td>
                    <p>
                      20 ns
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      Boost.Mixin msg
                    </p>
                  </td>
<td>
                    <p>
                      4942 ms
                    </p>
                  </td>
<td>
                    <p>
                      50 ns
                    </p>
                  </td>
<td>
                    <p>
                      1986 ms
                    </p>
                  </td>
<td>
                    <p>
                      20 ns
                    </p>
                  </td>
</tr>
</tbody>
</table></div>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
                OS: Windows 7
              </li>
<li class="listitem">
                CPU: AMD FX 4100
              </li>
<li class="listitem">
                Compiler: msvc 9 (Visual Studio 2008)
              </li>
<li class="listitem">
                Debug compilation parameters: Standard (<code class="computeroutput"><span class="special">/</span><span class="identifier">Od</span> <span class="special">/</span><span class="identifier">EHsc</span> <span class="special">/</span><span class="identifier">RTC1</span> <span class="special">/</span><span class="identifier">MDd</span> <span class="special">/</span><span class="identifier">ZI</span></code>)
              </li>
<li class="listitem">
                Release compilation parameters: Standard, but with no link time code
                generation (<code class="computeroutput"><span class="special">/</span><span class="identifier">O2</span>
                <span class="special">/</span><span class="identifier">Oi</span>
                <span class="special">/</span><span class="identifier">EHsc</span>
                <span class="special">/</span><span class="identifier">MD</span>
                <span class="special">/</span><span class="identifier">Gy</span>
                <span class="special">/</span><span class="identifier">Zi</span></code>)
              </li>
</ul></div>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                    <p>
                      Method
                    </p>
                  </th>
<th>
                    <p>
                      Debug
                    </p>
                  </th>
<th>
                    <p>
                      Debug mean
                    </p>
                  </th>
<th>
                    <p>
                      Release
                    </p>
                  </th>
<th>
                    <p>
                      Release mean
                    </p>
                  </th>
</tr></thead>
<tbody>
<tr>
<td>
                    <p>
                      Regular
                    </p>
                  </td>
<td>
                    <p>
                      4103 ms
                    </p>
                  </td>
<td>
                    <p>
                      41 ns
                    </p>
                  </td>
<td>
                    <p>
                      1419 ms
                    </p>
                  </td>
<td>
                    <p>
                      14 ns
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      Virtual
                    </p>
                  </td>
<td>
                    <p>
                      5585 ms
                    </p>
                  </td>
<td>
                    <p>
                      55 ns
                    </p>
                  </td>
<td>
                    <p>
                      1560 ms
                    </p>
                  </td>
<td>
                    <p>
                      16 ns
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">function</span></code>
                    </p>
                  </td>
<td>
                    <p>
                      45240 ms
                    </p>
                  </td>
<td>
                    <p>
                      452 ns
                    </p>
                  </td>
<td>
                    <p>
                      1919 ms
                    </p>
                  </td>
<td>
                    <p>
                      19 ns
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      Boost.Mixin msg
                    </p>
                  </td>
<td>
                    <p>
                      25100 ms
                    </p>
                  </td>
<td>
                    <p>
                      251 ns
                    </p>
                  </td>
<td>
                    <p>
                      2714 ms
                    </p>
                  </td>
<td>
                    <p>
                      27 ns
                    </p>
                  </td>
</tr>
</tbody>
</table></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_mixin.advanced.performance.msg_perf.optimize_msg"></a><a class="link" href="advanced.html#boost_mixin.advanced.performance.msg_perf.optimize_msg" title="Optimizing message calls">Optimizing
          message calls</a>
</h5></div></div></div>
<p>
            The stand-alone functions generated for messages typically have an <code class="computeroutput"><span class="keyword">if</span></code> statement in them. It's there so as
            to throw an exception if none of the mixins in an object implements the
            message. If you disable the library's exceptions those <code class="computeroutput"><span class="keyword">if</span></code>-s will be converted to <code class="computeroutput"><span class="identifier">assert</span></code>-s (which in non-debug compilations
            are simply ignored).
          </p>
<p>
            If you don't want to recompile the library with exceptions disabled,
            or if you just want all other exceptions, but not these, you can disable
            the throwing of exceptions from the message functions if you define
            <code class="computeroutput"><span class="identifier">BOOST_MIXIN_NO_MSG_THROW</span></code>
            <span class="emphasis"><em>before</em></span> including the Boost.Mixin headers.
          </p>
<p>
            Note that if you disable the exceptions from the message functions, calling
            a message on an object that doesn't implement it, will certainly lead
            to undefined behavior and crashes.
          </p>
<p>
            Also have in mind, that removing the 'if'-s will improve the performance
            by only a small amount of nanoseconds per message call on a modern CPU.
            Situations where such a thing could be significant should be very very
            rare.
          </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.advanced.performance.mutation_perf"></a><a class="link" href="advanced.html#boost_mixin.advanced.performance.mutation_perf" title="Mutation performance">Mutation
        performance</a>
</h4></div></div></div>
<p>
          <a class="indexterm" name="idp36223936"></a>
        </p>
<p>
          An object mutation can be a relatively slow operation.
        </p>
<p>
          Every mutation will invoke all mutation rules registered within the system.
          Their speed may vary and will depend on whether they end up changing the
          mutation or not. If they do change it, some allocation may take place.
          Even if they don't, each of them will be invoked by a virtual function
          and will have at least one 'if' check (possibly more, depending on the
          mutation rule).
        </p>
<p>
          If the mutation ends up creating a new type &#8211; a mixin combination
          that hasn't yet been met &#8211; this will also lead to the relatively
          slow process of initializing the internal data structures for that type.
          This will lead to some allocations and loops that generate the type's call
          table.
        </p>
<p>
          Even if the mutation doesn't generate a new type, it will have to find
          the existing one, which is a hash table lookup with key a bitset of size
          <code class="computeroutput"><span class="identifier">BOOST_MIXIN_MAX_MIXINS</span></code>.
        </p>
<p>
          Finally, the mutation will change the object (unless it happens to be an
          identity mutation &#8211; adding and removing nothing). To change it it
          will have to allocate new mixin data for it &#8211; an array of pointers
          to mixins, then deallocate any mixins being removed and allocate any mixins
          being added, and finally deallocate the old mixin data for the object.
        </p>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_mixin.advanced.performance.mutation_perf.optimize_mutation"></a><a class="link" href="advanced.html#boost_mixin.advanced.performance.mutation_perf.optimize_mutation" title="Optimizing mutations">Optimizing
          mutations</a>
</h5></div></div></div>
<p>
            Using <code class="computeroutput"><span class="identifier">object_type_template</span></code>
            or <code class="computeroutput"><span class="identifier">same_type_mutator</span></code>
            will perform the first steps &#8211; the ones concerning the identification
            of the object's type &#8211; only once.
          </p>
<p>
            To reduce the allocations for the individual object's being mutated,
            you can add custom allocators to some of the mixins or to the entire
            domain.
          </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h5 class="title">
<a name="boost_mixin.advanced.performance.mutation_perf.mutation_perf_test"></a><a class="link" href="advanced.html#boost_mixin.advanced.performance.mutation_perf.mutation_perf_test" title="Mutations performance test">Mutations
          performance test</a>
</h5></div></div></div>
<p>
            The mutation performance tests performs a couple of tasks to evaluate
            the time they consume:
          </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
                <span class="bold"><strong>New type</strong></span> &#8211; Creation of new
                types. Mutating objects in such a way that each mutation triggers
                the creation of a new object type.
              </li>
<li class="listitem">
                <span class="bold"><strong>Existing type</strong></span> &#8211; Creation
                of objects with a type template, such that each object is created
                with a type, that's already been met in the system.
              </li>
<li class="listitem">
                <span class="bold"><strong>Mutate</strong></span> &#8211; Mutation of objects
                of different types with a target an existing type.
              </li>
<li class="listitem">
                <span class="bold"><strong>Same type mutate</strong></span>: Mutation of objects
                of the same type with <code class="computeroutput"><span class="identifier">same_type_mutator</span></code>.
                It adds two mixins and removes one.
              </li>
<li class="listitem">
                <span class="bold"><strong>Custom allocator</strong></span>: Mutation of objects
                of different types with a mixin that has a custom allocator attached.
                The custom allocator preallocates pools of 100,000 mixins.
              </li>
<li class="listitem">
                <span class="bold"><strong>Same type alloc</strong></span>: Mutation of objects
                of the same type with <code class="computeroutput"><span class="identifier">same_type_mutator</span></code>.
                It adds a mixin with the same custom allocator.
              </li>
</ul></div>
<p>
            Here is a sample test result:
          </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
                OS: Ubuntu 13.04
              </li>
<li class="listitem">
                CPU: AMD FX X8 8150
              </li>
<li class="listitem">
                Compiler: g++ (Ubuntu/Linaro 4.7.3-1ubuntu1)
              </li>
<li class="listitem">
                Debug compilation parameters: <code class="computeroutput"><span class="special">-</span><span class="identifier">fexceptions</span> <span class="special">-</span><span class="identifier">g</span></code>
              </li>
<li class="listitem">
                Release compilation parameters <code class="computeroutput"><span class="special">-</span><span class="identifier">fexceptions</span> <span class="special">-</span><span class="identifier">O2</span></code>
              </li>
</ul></div>
<div class="informaltable"><table class="table">
<colgroup>
<col>
<col>
<col>
</colgroup>
<thead><tr>
<th>
                    <p>
                      Task
                    </p>
                  </th>
<th>
                    <p>
                      Mean time in Debug
                    </p>
                  </th>
<th>
                    <p>
                      Mean time in Release
                    </p>
                  </th>
</tr></thead>
<tbody>
<tr>
<td>
                    <p>
                      New type
                    </p>
                  </td>
<td>
                    <p>
                      1900 ns
                    </p>
                  </td>
<td>
                    <p>
                      990 ns
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      Existing type
                    </p>
                  </td>
<td>
                    <p>
                      1662 ns
                    </p>
                  </td>
<td>
                    <p>
                      550 ns
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      Mutate
                    </p>
                  </td>
<td>
                    <p>
                      6700 ns
                    </p>
                  </td>
<td>
                    <p>
                      697 ns
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      Same type mutate
                    </p>
                  </td>
<td>
                    <p>
                      1308 ns
                    </p>
                  </td>
<td>
                    <p>
                      322 ns
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      Custom allocator
                    </p>
                  </td>
<td>
                    <p>
                      5155 ns
                    </p>
                  </td>
<td>
                    <p>
                      544 ns
                    </p>
                  </td>
</tr>
<tr>
<td>
                    <p>
                      Same type alloc
                    </p>
                  </td>
<td>
                    <p>
                      1073 ns
                    </p>
                  </td>
<td>
                    <p>
                      158 ns
                    </p>
                  </td>
</tr>
</tbody>
</table></div>
</div>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.advanced.allocators"></a><a class="link" href="advanced.html#boost_mixin.advanced.allocators" title="Using custom allocators">Using custom allocators</a>
</h3></div></div></div>
<p>
        <a class="indexterm" name="idp36287504"></a>
      </p>
<p>
        (For the complete, working source of this example see <a href="https://github.com/iboB/boost.mixin/blob/master/tutorial/allocators.cpp" target="_top">allocators.cpp</a>)
      </p>
<p>
        Boost.Mixin allows you to set custom allocators for the persistent pieces
        of memory the library may require.
      </p>
<p>
        The library allocates some memory on initialization, which happens at a global
        scope &#8211; before the entry point of a program. It also has some allocations
        which are for instances with a very short lifetime. Currently those are not
        covered by the allocators.
      </p>
<p>
        What you can control with the custom allocators is the new memory allocated
        for <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">object</span></code> instances - their internal mixin
        data. You can assign a global allocator to the library and you can also set
        individual allocators per mixin type.
      </p>
<p>
        First let's see how you can create a global allocator. Let's assume you have
        a couple of functions of your own that allocate and deallocate memory in
        some way specific to your needs:
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">char</span><span class="special">*</span> <span class="identifier">allocate</span><span class="special">(</span><span class="identifier">size_t</span> <span class="identifier">size</span><span class="special">);</span>
<span class="keyword">void</span> <span class="identifier">deallocate</span><span class="special">(</span><span class="keyword">char</span><span class="special">*</span> <span class="identifier">buffer</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        To create a global allocator, you need to create a class derived from <code class="computeroutput"><span class="identifier">global_allocator</span></code> and override its virtual
        methods.
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">custom_allocator</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">global_allocator</span>
<span class="special">{</span>
</pre>
<p>
      </p>
<p>
        The first two methods allocate a buffer for the mixin data pointers. Every
        object has pointers to its mixins within it. This is the array of such pointers.
        The class <code class="computeroutput"><span class="identifier">global_allocator</span></code>
        has a static constant member &#8211; <code class="computeroutput"><span class="identifier">mixin_data_size</span></code>
        &#8211; which you should use to see the size of a single element in that
        array.
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">virtual</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">alloc_mixin_data</span><span class="special">(</span><span class="identifier">size_t</span> <span class="identifier">count</span><span class="special">)</span>
<span class="special">{</span>
    <span class="keyword">return</span> <span class="identifier">allocate</span><span class="special">(</span><span class="identifier">count</span> <span class="special">*</span> <span class="identifier">mixin_data_size</span><span class="special">);</span>
<span class="special">}</span>

<span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">dealloc_mixin_data</span><span class="special">(</span><span class="keyword">char</span><span class="special">*</span> <span class="identifier">ptr</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">deallocate</span><span class="special">(</span><span class="identifier">ptr</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        The other two methods you need to overload allocate and deallocate the memory
        for an actual mixin class instance. As you may have already read, the buffer
        allocated for a mixin instance is bigger than needed because the library
        stores a pointer to the owning object immediately before the memory used
        by the mixin instance.
      </p>
<p>
        That's why this function is not as simple as the one for the mixin data array.
        It has to conform to the mixin (and also <code class="computeroutput"><span class="identifier">object</span></code>
        pointer) alignment.
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">alloc_mixin</span><span class="special">(</span><span class="identifier">size_t</span> <span class="identifier">mixin_size</span><span class="special">,</span> <span class="identifier">size_t</span> <span class="identifier">mixin_alignment</span><span class="special">,</span> <span class="keyword">char</span><span class="special">*&amp;</span> <span class="identifier">out_buffer</span><span class="special">,</span> <span class="identifier">size_t</span><span class="special">&amp;</span> <span class="identifier">out_mixin_offset</span><span class="special">)</span>
<span class="special">{</span>
</pre>
<p>
      </p>
<p>
        The users are strongly advised to use the static method <code class="computeroutput"><span class="identifier">global_allocator</span><span class="special">::</span><span class="identifier">calculate_mem_size_for_mixin</span></code>.
        It will appropriately calculate how much memory is needed for the mixin instance
        such that there is enough room at the beginning for the pointer to the owning
        object and the memory alignment is respected.
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">size_t</span> <span class="identifier">size</span> <span class="special">=</span> <span class="identifier">calculate_mem_size_for_mixin</span><span class="special">(</span><span class="identifier">mixin_size</span><span class="special">,</span> <span class="identifier">mixin_alignment</span><span class="special">);</span>
<span class="identifier">out_buffer</span> <span class="special">=</span> <span class="identifier">allocate</span><span class="special">(</span><span class="identifier">size</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        After you allocate the buffer you should take care of the other output parameter
        - the mixin offset. It calculates the offset of the actual mixin instance
        memory within the buffer, such that there is room for the owning object pointer
        in before it and all alignments are respected.
      </p>
<p>
        You are encouraged to use the static method <code class="computeroutput"><span class="identifier">global_allocator</span><span class="special">::</span><span class="identifier">calculate_mixin_offset</span></code>
        for this purpose.
      </p>
<p>
</p>
<pre class="programlisting">    <span class="identifier">out_mixin_offset</span> <span class="special">=</span> <span class="identifier">calculate_mixin_offset</span><span class="special">(</span><span class="identifier">out_buffer</span><span class="special">,</span> <span class="identifier">mixin_alignment</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        The mixin instance deallocation method can be trivial
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">dealloc_mixin</span><span class="special">(</span><span class="keyword">char</span><span class="special">*</span> <span class="identifier">ptr</span><span class="special">)</span>
<span class="special">{</span>
    <span class="identifier">deallocate</span><span class="special">(</span><span class="identifier">ptr</span><span class="special">);</span>
<span class="special">}</span>
</pre>
<p>
      </p>
<p>
        To use the custom global allocator you need to instantiate it and then set
        it with <code class="computeroutput"><span class="identifier">set_global_allocator</span></code>.
        Unlike the mutation rules, the responsibility for the allocator instance
        is yours. You need to make sure that the lifetime of the instance is at least
        as long as the lifetime of all objects in the system.
      </p>
<p>
        Unfortunately this means that if you have global or static objects, you need
        to create a new pointer that is, in a way, a memory leak. If you do not have
        global or static objects, it should be safe for it to just be a local variable
        in your program's entry point function.
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">custom_allocator</span> <span class="identifier">alloc</span><span class="special">;</span>
<span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">set_global_allocator</span><span class="special">(&amp;</span><span class="identifier">alloc</span><span class="special">);</span>
</pre>
<p>
      </p>
<p>
        As we mentioned before, you can have an allocator specific for a mixin type.
      </p>
<p>
        A common case for such use is to have a per-frame allocator &#8211; one
        that has a preallocated buffer which is used much like a stack, with its
        pointer reset at the end of each simulation frame (or at the beginning each
        new one). Let's create such an allocator.
      </p>
<p>
        First, a mixin instance allocator is not necessarily bound to a concrete
        mixin type. You can have the same instance of such an allocator set for many
        mixins (which would be a common use of a per-frame allocator), but for our
        example let's create one that <span class="emphasis"><em>is</em></span> bound to an instance.
        We will make it a template class because the code for each mixin type will
        be the same.
      </p>
<p>
        A mixin instance allocator needs to be derived from the class <code class="computeroutput"><span class="identifier">mixin_allocator</span></code>. You then need to overload
        its two virtual methods which are exactly the same as the mixin instance
        allocation/deallocation methods in <code class="computeroutput"><span class="identifier">global_allocator</span></code>.
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">template</span> <span class="special">&lt;</span><span class="keyword">typename</span> <span class="identifier">Mixin</span><span class="special">&gt;</span>
<span class="keyword">class</span> <span class="identifier">per_frame_allocator</span> <span class="special">:</span> <span class="keyword">public</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">mixin_allocator</span>
<span class="special">{</span>
<span class="keyword">private</span><span class="special">:</span>
    <span class="keyword">static</span> <span class="keyword">const</span> <span class="identifier">size_t</span> <span class="identifier">NUM_IN_PAGE</span> <span class="special">=</span> <span class="number">1000</span><span class="special">;</span>

    <span class="identifier">size_t</span> <span class="identifier">_num_allocations</span><span class="special">;</span> <span class="comment">// number of "living" instances allocated</span>
    <span class="keyword">const</span> <span class="identifier">size_t</span> <span class="identifier">mixin_buf_size</span><span class="special">;</span> <span class="comment">// the size of a single mixin instance buffer</span>
    <span class="identifier">vector</span><span class="special">&lt;</span><span class="keyword">char</span><span class="special">*&gt;</span> <span class="identifier">_pages</span><span class="special">;</span> <span class="comment">// use pages of data where each page can store NUM_IN_PAGE instances</span>
    <span class="identifier">size_t</span> <span class="identifier">_page_byte_index</span><span class="special">;</span> <span class="comment">// index within a memory "page"</span>
    <span class="keyword">const</span> <span class="identifier">size_t</span> <span class="identifier">page_size</span><span class="special">;</span> <span class="comment">// size in bytes of a page</span>

<span class="keyword">public</span><span class="special">:</span>

    <span class="comment">// some way to obtain the instance</span>
    <span class="keyword">static</span> <span class="identifier">per_frame_allocator</span><span class="special">&amp;</span> <span class="identifier">instance</span><span class="special">()</span>
    <span class="special">{</span>
        <span class="keyword">static</span> <span class="identifier">per_frame_allocator</span> <span class="identifier">i</span><span class="special">;</span>
        <span class="keyword">return</span> <span class="identifier">i</span><span class="special">;</span>
    <span class="special">}</span>


    <span class="identifier">per_frame_allocator</span><span class="special">()</span>
        <span class="special">:</span> <span class="identifier">mixin_buf_size</span><span class="special">(</span>
            <span class="identifier">calculate_mem_size_for_mixin</span><span class="special">(</span>
                <span class="keyword">sizeof</span><span class="special">(</span><span class="identifier">Mixin</span><span class="special">),</span>
                <span class="identifier">boost</span><span class="special">::</span><span class="identifier">alignment_of</span><span class="special">&lt;</span><span class="identifier">Mixin</span><span class="special">&gt;::</span><span class="identifier">value</span><span class="special">))</span>
        <span class="special">,</span> <span class="identifier">_num_allocations</span><span class="special">(</span><span class="number">0</span><span class="special">)</span>
        <span class="special">,</span> <span class="identifier">page_size</span><span class="special">(</span><span class="identifier">mixin_buf_size</span> <span class="special">*</span> <span class="identifier">NUM_IN_PAGE</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="identifier">new_memory_page</span><span class="special">();</span>
    <span class="special">}</span>

    <span class="keyword">void</span> <span class="identifier">new_memory_page</span><span class="special">()</span>
    <span class="special">{</span>
        <span class="keyword">char</span><span class="special">*</span> <span class="identifier">page</span> <span class="special">=</span> <span class="keyword">new</span> <span class="keyword">char</span><span class="special">[</span><span class="identifier">page_size</span><span class="special">];</span>
        <span class="identifier">_pages</span><span class="special">.</span><span class="identifier">push_back</span><span class="special">(</span><span class="identifier">page</span><span class="special">);</span>
        <span class="identifier">_page_byte_index</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
    <span class="special">}</span>
    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">alloc_mixin</span><span class="special">(</span><span class="identifier">size_t</span> <span class="identifier">mixin_class_size</span><span class="special">,</span> <span class="identifier">size_t</span> <span class="identifier">mixin_alignment</span><span class="special">,</span> <span class="keyword">char</span><span class="special">*&amp;</span> <span class="identifier">out_buffer</span><span class="special">,</span> <span class="identifier">size_t</span><span class="special">&amp;</span> <span class="identifier">out_mixin_offset</span><span class="special">)</span>
    <span class="special">{</span>
        <span class="keyword">if</span><span class="special">(</span><span class="identifier">_page_byte_index</span> <span class="special">==</span> <span class="identifier">NUM_IN_PAGE</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="comment">// if we don't have space in our current page, create a new one</span>
            <span class="identifier">new_memory_page</span><span class="special">();</span>
        <span class="special">}</span>

        <span class="identifier">out_buffer</span> <span class="special">=</span> <span class="identifier">_pages</span><span class="special">.</span><span class="identifier">back</span><span class="special">()</span> <span class="special">+</span> <span class="identifier">_page_byte_index</span> <span class="special">*</span> <span class="identifier">mixin_buf_size</span><span class="special">;</span>

        <span class="comment">// again calculate the offset using this static member function</span>
        <span class="identifier">out_mixin_offset</span> <span class="special">=</span> <span class="identifier">calculate_mixin_offset</span><span class="special">(</span><span class="identifier">out_buffer</span><span class="special">,</span> <span class="identifier">mixin_alignment</span><span class="special">);</span>

        <span class="special">++</span><span class="identifier">_page_byte_index</span><span class="special">;</span>
        <span class="special">++</span><span class="identifier">_num_allocations</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="keyword">virtual</span> <span class="keyword">void</span> <span class="identifier">dealloc_mixin</span><span class="special">(</span><span class="keyword">char</span><span class="special">*</span> <span class="identifier">buf</span><span class="special">)</span>
    <span class="special">{</span>
<span class="preprocessor">#if</span> <span class="special">!</span><span class="identifier">defined</span><span class="special">(</span><span class="identifier">NDEBUG</span><span class="special">)</span>
        <span class="comment">// in debug mode check if the mixin is within any of our pages</span>
        <span class="keyword">for</span><span class="special">(</span><span class="identifier">size_t</span> <span class="identifier">i</span><span class="special">=</span><span class="number">0</span><span class="special">;</span> <span class="identifier">i</span><span class="special">&lt;</span><span class="identifier">_pages</span><span class="special">.</span><span class="identifier">size</span><span class="special">();</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">page_begin</span> <span class="special">=</span> <span class="identifier">_pages</span><span class="special">[</span><span class="identifier">i</span><span class="special">];</span>
            <span class="keyword">const</span> <span class="keyword">char</span><span class="special">*</span> <span class="identifier">page_end</span> <span class="special">=</span> <span class="identifier">page_begin</span> <span class="special">+</span> <span class="identifier">page_size</span><span class="special">;</span>

            <span class="identifier">BOOST_ASSERT</span><span class="special">(</span><span class="identifier">buf</span> <span class="special">&gt;=</span> <span class="identifier">page_begin</span> <span class="special">&amp;&amp;</span> <span class="identifier">buf</span> <span class="special">&lt;</span> <span class="identifier">page_end</span><span class="special">);</span>
        <span class="special">}</span>
<span class="preprocessor">#else</span>
        <span class="identifier">buf</span><span class="special">;</span> <span class="comment">// to skip warning for unused parameter</span>
<span class="preprocessor">#endif</span>
        <span class="comment">// no actual deallocation to be done</span>
        <span class="comment">// just decrement our living instances counter</span>

        <span class="special">--</span><span class="identifier">_num_allocations</span><span class="special">;</span>
    <span class="special">}</span>

    <span class="comment">// function to be called once each frame that resets the allocator</span>
    <span class="keyword">void</span> <span class="identifier">reset</span><span class="special">()</span>
    <span class="special">{</span>
        <span class="identifier">BOOST_ASSERT</span><span class="special">(</span><span class="identifier">_num_allocations</span> <span class="special">==</span> <span class="number">0</span><span class="special">);</span> <span class="comment">// premature reset</span>
        <span class="keyword">for</span><span class="special">(</span><span class="identifier">size_t</span> <span class="identifier">i</span><span class="special">=</span><span class="number">1</span><span class="special">;</span> <span class="identifier">i</span><span class="special">&lt;</span><span class="identifier">_pages</span><span class="special">.</span><span class="identifier">size</span><span class="special">();</span> <span class="special">++</span><span class="identifier">i</span><span class="special">)</span>
        <span class="special">{</span>
            <span class="keyword">delete</span><span class="special">[]</span> <span class="identifier">_pages</span><span class="special">[</span><span class="identifier">i</span><span class="special">];</span>
        <span class="special">}</span>

        <span class="identifier">_page_byte_index</span> <span class="special">=</span> <span class="number">0</span><span class="special">;</span>
    <span class="special">}</span>
<span class="special">};</span>
</pre>
<p>
      </p>
<p>
        Now this class can be set as a mixin allocator for a given mixin type. A
        side effect of the fact that it's bound to the type is that it keeps mixin
        instances in a continuous buffer. With some changes (to take care of potential
        holes in the buffer) such an allocator can be used by a subsystem that works
        through mixins relying on them being in a continuous buffer to avoid cache
        misses.
      </p>
<p>
        To illustrate a usage for our mixin allocator, let's imagine we have a game.
        If a character in our game dies, it will be destroyed at the end of the current
        frame and should stop responding to any messages. We can create a mixin called
        <code class="computeroutput"><span class="identifier">dead_character</span></code> which implements
        all those the messages with a higher priority than the rest of the mixins.
        Since every object that has a <code class="computeroutput"><span class="identifier">dead_character</span></code>
        mixin will be destroyed by the end of the frame, it will be safe to use the
        per-frame allocator for it.
      </p>
<p>
        First let's create the mixin class and sample messages:
      </p>
<p>
</p>
<pre class="programlisting"><span class="keyword">class</span> <span class="identifier">dead_character</span>
<span class="special">{</span>
<span class="keyword">public</span><span class="special">:</span>
    <span class="keyword">void</span> <span class="identifier">die</span><span class="special">()</span> <span class="special">{}</span>
    <span class="comment">// ...</span>
<span class="special">};</span>

<span class="identifier">BOOST_MIXIN_MESSAGE_0</span><span class="special">(</span><span class="keyword">void</span><span class="special">,</span> <span class="identifier">die</span><span class="special">);</span>
<span class="identifier">BOOST_MIXIN_DEFINE_MESSAGE</span><span class="special">(</span><span class="identifier">die</span><span class="special">);</span>
<span class="comment">//...</span>
</pre>
<p>
      </p>
<p>
        Now we define the mixin so that it uses the allocator, we just need to add
        it with "<code class="computeroutput"><span class="special">&amp;</span></code>" to
        the mixin feature list, just like we add messages. There are two ways to
        do so. The first one would be to do it like this:
      </p>
<pre class="programlisting"><span class="identifier">BOOST_DEFINE_MIXIN</span><span class="special">(</span><span class="identifier">dead_character</span><span class="special">,</span> <span class="special">...</span> <span class="special">&amp;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">priority</span><span class="special">(</span><span class="number">1</span><span class="special">,</span> <span class="identifier">die_msg</span><span class="special">)</span>
    <span class="special">&amp;</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">allocator</span><span class="special">&lt;</span><span class="identifier">per_frame_allocator</span><span class="special">&lt;</span><span class="identifier">dead_character</span><span class="special">&gt;&gt;());</span>
</pre>
<p>
        This will create the instance of the allocator internally and we won't be
        able to get it. Since in our case we do care about the instance because we
        want to call its <code class="computeroutput"><span class="identifier">reset</span></code> method,
        we could use an alternative way, by just adding an actual instance of the
        allocator to the feature list:
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">BOOST_DEFINE_MIXIN</span><span class="special">(</span><span class="identifier">dead_character</span><span class="special">,</span> <span class="comment">/*...*/</span> <span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">priority</span><span class="special">(</span><span class="number">1</span><span class="special">,</span> <span class="identifier">die_msg</span><span class="special">)</span>
    <span class="special">&amp;</span> <span class="identifier">per_frame_allocator</span><span class="special">&lt;</span><span class="identifier">dead_character</span><span class="special">&gt;::</span><span class="identifier">instance</span><span class="special">());</span>
</pre>
<p>
      </p>
<p>
        If we share a mixin instance allocator between multiple mixins, the second
        way is also the way to go.
      </p>
<p>
        Now all mixin allocations and deallocations will pass through our mixin allocator:
      </p>
<p>
</p>
<pre class="programlisting"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">object</span> <span class="identifier">o</span><span class="special">;</span>

<span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">mutate</span><span class="special">(</span><span class="identifier">o</span><span class="special">)</span>
    <span class="special">.</span><span class="identifier">add</span><span class="special">&lt;</span><span class="identifier">dead_character</span><span class="special">&gt;();</span>

<span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">mutate</span><span class="special">(</span><span class="identifier">o</span><span class="special">)</span>
    <span class="special">.</span><span class="identifier">remove</span><span class="special">&lt;</span><span class="identifier">dead_character</span><span class="special">&gt;();</span>

<span class="comment">// safe because we've destroyed all instances of `dead_character`</span>
<span class="identifier">per_frame_allocator</span><span class="special">&lt;</span><span class="identifier">dead_character</span><span class="special">&gt;::</span><span class="identifier">instance</span><span class="special">().</span><span class="identifier">reset</span><span class="special">();</span>
</pre>
<p>
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.advanced.arity"></a><a class="link" href="advanced.html#boost_mixin.advanced.arity" title="Having messages with more arguments">Having messages with more
      arguments</a>
</h3></div></div></div>
<p>
        Currently the maximum number of arguments you can have in a message is:
      </p>
<p>
        4
      </p>
<p>
        There simply is no message declaration macro for messages with more. If you
        need macros for messages with more arguments, you can do so, without having
        to rebuild the library.
      </p>
<p>
        In your Boost.Mixin installation, in the <code class="computeroutput"><span class="identifier">gen</span></code>
        directory you will see a file, named <code class="computeroutput"><span class="identifier">arity</span></code>.
        It is a text file with a single number in it. Edit the file, setting the
        number to whichever value you need. Then run the script <code class="computeroutput"><span class="identifier">gen_message_macros</span><span class="special">.</span><span class="identifier">rb</span></code> (you
        will need a Ruby interpreter to do so). It will generate the file <code class="computeroutput"><span class="identifier">include</span><span class="special">/</span><span class="identifier">boost</span><span class="special">/</span><span class="identifier">mixin</span><span class="special">/</span><span class="identifier">gen</span><span class="special">/</span><span class="identifier">message_macros</span><span class="special">.</span><span class="identifier">ipp</span></code> with
        macros for messages with 0 to <span class="emphasis"><em>arity</em></span> arguments.
      </p>
<p>
        If you use an include directory for Boost.Mixin diferent from the one in
        your installation, you will have to manually copy the newly generated message
        macros file over the one you use.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.advanced.dynlib"></a><a class="link" href="advanced.html#boost_mixin.advanced.dynlib" title="Dynamic libraries and program plugins">Dynamic libraries and program
      plugins</a>
</h3></div></div></div>
<p>
        As long as the library itself is dynamic (<code class="computeroutput"><span class="special">.</span><span class="identifier">dll</span></code> on Windows or <code class="computeroutput"><span class="special">.</span><span class="identifier">so</span></code> on Unix or Linux) its safe to use in
        an application that has dynamic libraries which use Boost.Mixin.
      </p>
<p>
        An interesting thing which you can accomplish with the library is to have
        optional plugins &#8211; dynamic libraries that aren't linked with the executable
        but may or may not be present, and if they are, they are being loaded dynamically
        (with <code class="computeroutput"><span class="identifier">LoadLibrary</span></code> or <code class="computeroutput"><span class="identifier">dlopen</span></code>).
      </p>
<p>
        Such plugin may add a mutation rule for its special mixins, or export functions
        that mutate objects.
      </p>
<p>
        For example this may be very useful for an engineering CAD system that could
        potentially have many different optional plugins for its different needs.
        Say, a plugin that extends the buildings with electrical wiring could simply
        mutate objects, adding a mixin mixin called <code class="computeroutput"><span class="identifier">electrical_wiring</span></code>
        that contains the appropriate functionality.
      </p>
<p>
        There is only one thing you need to remember when you're exporting mixins
        or messages from a dynamic library: to use the export macros: <code class="computeroutput"><span class="identifier">BOOST_DECLARE_EXPORTED_MIXIN</span></code> and <code class="computeroutput"><span class="identifier">BOOST_MIXIN_EXPORTED_xxx_MESSAGE_N</span></code>. They
        are exactly like their regular counterparts but for their first argument,
        which is the compiler specific export symbol (<code class="computeroutput"><span class="identifier">__declspec</span><span class="special">(</span><span class="identifier">dllexport</span><span class="special">)</span></code> for Visual C++ or just <code class="computeroutput"><span class="identifier">BOOST_SYMBOL_EXPORT</span></code>
        if you're using Boost).
      </p>
<p>
        <a class="link" href="examples.html#boost_mixin.examples.multi_dll" title="Multi DLL">One of the examples</a>
        that come with the library illustrates how you can have the two types of
        dynamic libraries &#8211; one which you link with, and one plugin.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.advanced.implementation"></a><a class="link" href="advanced.html#boost_mixin.advanced.implementation" title="Implementation notes">Implementation notes</a>
</h3></div></div></div>
<p>
        Here are some explanations that may help you make sense of the code of the
        library if you need to read it:
      </p>
<p>
        The overall structure of the library is based on a main class called <code class="computeroutput"><span class="identifier">domain</span></code> which holds all registered mixins
        and messages, and keeps the type registry.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.advanced.implementation.reg"></a><a class="link" href="advanced.html#boost_mixin.advanced.implementation.reg" title="Mixin and feature registration">Mixin and
        feature registration</a>
</h4></div></div></div>
<p>
          The <code class="computeroutput"><span class="identifier">BOOST_DEFINE_MIXIN</span></code>
          macro instantiates a class that is similar to a metafunction, as its only
          purpose is to globally instantiate itself, which in turn will lead to
          <code class="computeroutput"><span class="identifier">domain</span><span class="special">::</span><span class="identifier">register_mixin_type</span></code> being called.
        </p>
<p>
          It also generates a function that registers the mixin features.
        </p>
<p>
          <code class="computeroutput"><span class="identifier">domain</span><span class="special">::</span><span class="identifier">register_mixin_type</span></code> is a template method
          and it will appropriately fill a structure, containing the mixin type information
          &#8211; name, constructor, destructor, id &#8211; and will also call
          the generated function that registers its features.
        </p>
<p>
          The feature registration is composed of two parts: one global - to introduce
          the feature to the domain, and local called for the specific mixin type
          being registered. This means that a feature is globally registered multiple
          times - once for each of its uses for a mixin type. The first of those
          times will give it an id and fill the feature information structure appropriately.
          The other global registrations of a feature will see that it has a valid
          id, and will simply skip the rest of the code.
        </p>
<p>
          The local feature registration is performed by the class <code class="computeroutput"><span class="identifier">feature_parser</span></code> that has overloads for
          the supported mixin features: currently messages and allocators. The allocator
          registration is simple. It just sets the allocator member in the mixin
          type information structure to the appropriate value.
        </p>
<p>
          The message registration generates a caller function, based on the specific
          mixin. This caller function is a specific instantiation of a template function
          which is generated by the message declaration macros. Its template parameters
          are the mixin type and the actual member function in the mixin. The caller
          is then cast to <code class="computeroutput"><span class="keyword">void</span> <span class="special">(*)()</span></code>
          to be stored in a vector in the mixin type information structure along
          with the caller functions for all of its messages.
        </p>
<p>
          This process of creating a caller function is based on the article <a href="http://www.codeproject.com/Articles/11015/The-Impossibly-Fast-C-Delegates" target="_top">The
          Impossibly Fast C++ Delegates</a> by Sergey Ryazanov.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.advanced.implementation.reg0"></a><a class="link" href="advanced.html#boost_mixin.advanced.implementation.reg0" title="Mixin and message id-s">Mixin and
        message id-s</a>
</h4></div></div></div>
<p>
          Each newly registered mixin and message get an id. The id-s are consecutive
          indexes in arrays (of <code class="computeroutput"><span class="identifier">mixin_type_info</span></code>
          and <code class="computeroutput"><span class="identifier">message_t</span></code> respectively)
          in the domain. Thus getting the information for a mixin or a message through
          its id is a O(1) operation.
        </p>
<p>
          The maximum numbers of registered messages and mixins are fixed through
          the constants <code class="computeroutput"><span class="identifier">BOOST_MIXIN_MAX_MIXINS</span></code>
          and <code class="computeroutput"><span class="identifier">BOOST_MIXIN_MAX_MESSAGES</span></code>
          in <code class="computeroutput"><span class="identifier">config</span><span class="special">.</span><span class="identifier">hpp</span></code>.
        </p>
<p>
          This allows us to have fixed-size arrays for both in the domain and per
          object type.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.advanced.implementation.reg1"></a><a class="link" href="advanced.html#boost_mixin.advanced.implementation.reg1" title="Mutation and type information">Mutation
        and type information</a>
</h4></div></div></div>
<p>
          A new object type is initially identified via a bitset per mixin. The domain
          contains an unordered (hash) map where the key is such a bitset, and the
          value is an object type info.
        </p>
<p>
          The object type info consists of such a bitset (to mark which mixins are
          available in this type), a compact vector of mixin type information structures
          a cross indexing array (to indicate which mixin data is at which position
          in the compact array), and a call table.
        </p>
<p>
          The call table plays the same role as the virtual table in C++. It's a
          fixed size array for every message with non-null values for the messages
          that are implemented by that type. An element of that array is of type
          <code class="computeroutput"><span class="identifier">call_table_entry</span></code>. This
          is a union that, based on whether the message is a unicast or a multicast,
          will contain the message data or a begin and an end for a buffer or message
          datas.
        </p>
<p>
          When a type is requested for an object, first it's checked whether such
          a combination of mixins is an existing type. If not a new object type is
          created. This fills the mixin information bitset, vector and cross indexing
          array and then fills the call table. It will allocate a single buffer for
          all multicast messages within that type. When filling the call table the
          type creation process will choose the top priority unicast messages and
          sort the multicasts by priority. It will throw an exception if same-priority
          unicasts exist.
        </p>
<p>
          After the type is available the object data needs to be filled. The object
          consists of a pointer to its type and an array of the structure <code class="computeroutput"><span class="identifier">mixin_data_in_object</span></code>. This structure
          wraps a simple buffer that contains the mixin instance and a pointer to
          the owning object right in front of it. This is required for the need to
          get the owning object from within the code of the mixin class (made through
          <code class="computeroutput"><span class="identifier">bm_this</span></code> or <code class="computeroutput"><span class="identifier">object_of</span></code>). Thus, getting the owning
          object from the mixin is an offset from the <code class="computeroutput"><span class="keyword">this</span></code>
          pointer.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.advanced.implementation.msg_call"></a><a class="link" href="advanced.html#boost_mixin.advanced.implementation.msg_call" title="Calling messages">Calling
        messages</a>
</h4></div></div></div>
<p>
          The message calling happens through the message functions which are generated
          by the message declaration macros.
        </p>
<p>
          The call consists of the following steps:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              Get the message info through a function generated by the message definition
              macro
            </li>
<li class="listitem">
              Get the call table entry for this message from the object's type
            </li>
<li class="listitem">
              Get the mixin info and the caller function from the call table entry
            </li>
<li class="listitem">
              Get the mixin pointer from the object, based on the mixin info
            </li>
<li class="listitem">
              Cast the caller function from <code class="computeroutput"><span class="keyword">void</span>
              <span class="special">(*)()</span></code> to the appropriate signature.
            </li>
<li class="listitem">
              Call the caller function for the mixin pointer.
            </li>
</ul></div>
<p>
          For multicasts there is a <code class="computeroutput"><span class="keyword">for</span></code>
          loop for the last four steps.
        </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.advanced.macros"></a><a class="link" href="advanced.html#boost_mixin.advanced.macros" title="Macros rationale">Macros rationale</a>
</h3></div></div></div>
<p>
        Many people, upon seeing Boost.Mixin for the first time, have expressed a
        concern with the seemingly excessive amount of macros the library's users
        are required to write.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.advanced.macros.mixin"></a><a class="link" href="advanced.html#boost_mixin.advanced.macros.mixin" title="Mixin definition and declaration macros">Mixin definition
        and declaration macros</a>
</h4></div></div></div>
<p>
          The mixin definition and declaration macros are often mentioned as easy
          to remove, and indeed there is a way to reproduce almost all of their functionality
          without any macros. However not all of it can be reproduced.
        </p>
<p>
          One of the key features those macros provide is the global instantiation.
          Without them, the users will be required to provide explicit entry points
          for their subsystems and dynamic libraries, where they will have to call
          some mixin initialization functions. This is not as simple as it sounds.
          Here is a list of downsides that such explicit entry points may introduce:
        </p>
<div class="itemizedlist"><ul class="itemizedlist" type="disc">
<li class="listitem">
              They will be compilation dependency "focal points": All mixins
              classes introduced by a subsystem would need to be visible from there,
              which means recompilations on every change, and more maintenance for
              the code.
            </li>
<li class="listitem">
              The users will have to be extra careful not to add mixins to objects
              before their initialization is called.
            </li>
<li class="listitem">
              Duplicated instances of the mixin data structures will exist in different
              modules (executable and dynamic libraries). In order to deal with this,
              the domain would need to store multiple copies of info for the same
              mixin. This will add a small runtime cost to the message calls and
              mutations.
            </li>
</ul></div>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.advanced.macros.message"></a><a class="link" href="advanced.html#boost_mixin.advanced.macros.message" title="Message definition and declaration macros">Message definition
        and declaration macros</a>
</h4></div></div></div>
<p>
          The message macros are most likely impossible to remove. Unlike the mixin
          ones, each of them generates many lines of code. More than a hundred.
        </p>
<p>
          Probably the only way to remove them completely, would be to make the message
          calls by string. This will cause the calls to make hash table look-ups
          (or worse) and will prohibitively slow them down. Such a scenario will
          also reflect on the way mixins are registerd. The mixin messages would
          have to be set through something that resembles <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">bind</span></code>
          adding yet more complexity to the user code.
        </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.advanced.macros.moc"></a><a class="link" href="advanced.html#boost_mixin.advanced.macros.moc" title="External custom preprocessor">External custom preprocessor</a>
</h4></div></div></div>
<p>
          Is is possible (and probably part of the future of the library) to create
          an external tool that makes the user code a bit nicer. It would resemble
          <a href="http://qt-project.org/doc/qt-4.8/moc.html" target="_top">The Meta-Object
          Compiler of Qt</a>, and similarly, would require a custom preprocessing
          step of the users' code.
        </p>
<p>
          Such a tool could theoretically solve more of the library's problems, like
          the need to call <code class="computeroutput"><span class="identifier">message</span><span class="special">(</span><span class="identifier">object</span><span class="special">)</span></code> instead of <code class="computeroutput"><span class="identifier">object</span><span class="special">.</span><span class="identifier">message</span><span class="special">()</span></code> at the very least, and many more...
        </p>
<p>
          Still, such an approach also has many opponents, as the code you write
          when you use it becomes effectively not-C++, but something that can be
          called a C++ dialect.
        </p>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2013, 2014 Borislav Stanimirov, Zahary Karadjov<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>).
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="debugging.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="../mixin/reference.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
