<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=US-ASCII">
<title>Glossary</title>
<link rel="stylesheet" href="../boostbook.css" type="text/css">
<meta name="generator" content="DocBook XSL Stylesheets V1.76.1">
<link rel="home" href="../index.html" title="Chapter&#160;1.&#160;Boost.Mixin 0.1">
<link rel="up" href="../index.html" title="Chapter&#160;1.&#160;Boost.Mixin 0.1">
<link rel="prev" href="using.html" title="Using Boost.Mixin">
<link rel="next" href="tutorials.html" title="Tutorials">
</head>
<body bgcolor="white" text="black" link="#0000FF" vlink="#840084" alink="#0000FF">
<div class="spirit-nav">
<a accesskey="p" href="using.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="tutorials.html"><img src="../images/next.png" alt="Next"></a>
</div>
<div class="section">
<div class="titlepage"><div><div><h2 class="title" style="clear: both">
<a name="boost_mixin.glossary"></a><a class="link" href="glossary.html" title="Glossary">Glossary</a>
</h2></div></div></div>
<div class="toc"><dl>
<dt><span class="section"><a href="glossary.html#boost_mixin.glossary.object">Objects</a></span></dt>
<dt><span class="section"><a href="glossary.html#boost_mixin.glossary.mixin">Mixins</a></span></dt>
<dt><span class="section"><a href="glossary.html#boost_mixin.glossary.message">Messages</a></span></dt>
<dt><span class="section"><a href="glossary.html#boost_mixin.glossary.priority">Message priority</a></span></dt>
<dt><span class="section"><a href="glossary.html#boost_mixin.glossary.combinators">Multicast result combinators</a></span></dt>
<dt><span class="section"><a href="glossary.html#boost_mixin.glossary.mutation">Mutations</a></span></dt>
</dl></div>
<p>
      Here is a list of the major idioms, introduced by Boost.Mixin.
    </p>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.glossary.object"></a><a class="link" href="glossary.html#boost_mixin.glossary.object" title="Objects">Objects</a>
</h3></div></div></div>
<p>
        <a class="indexterm" name="idp5413712"></a>
      </p>
<p>
        An object in terms of Boost.Mixin is an instance of the class <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">object</span></code>. By itself it's not much more than
        an empty class. Its main purpose is to be a "container" of mixin
        instances. You can construct an empty object and then add or remove mixins
        from it via the object mutators.
      </p>
<p>
        The particular set of mixins in an object defines its type. An object mutation
        (adding or removing mixins) changes the objects type.
      </p>
<p>
        Now, "type", as mentioned above has nothing to do with the concept
        of type in C++. A <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">object</span></code> naturally always is a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">:</span><span class="identifier">object</span></code>. The object's type is a runtime
        concept, which is rarely (or never) used in a program. Instead, what's relevant
        for objects is their interface &#8211; which messages they implement.
      </p>
<p>
        The purpose of the object is not much different from the objects in the regular
        OOP style, you're probably used to. If you're developing a game, every "thing"
        in the game's world could be a <code class="computeroutput"><span class="identifier">boost</span><span class="special">::</span><span class="identifier">mixin</span><span class="special">::</span><span class="identifier">object</span></code>.
        If you're developing a CAD system, every graphical element from a document
        could be one.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.glossary.mixin"></a><a class="link" href="glossary.html#boost_mixin.glossary.mixin" title="Mixins">Mixins</a>
</h3></div></div></div>
<p>
        <a class="indexterm" name="idp5431152"></a>
      </p>
<p>
        A mixin is a class used as a "building block" for an object. In
        Boost.Mixin a mixin doesn't have a specified type. It's the job of the library's
        users to define their own mixin types. There are several macros that you
        need to use in order to "tell" the library that one of your classes
        should be accepted as a mixin. The macros are non-intrusive and you don't
        need to change anything in existing code, to which you want to add Boost.Mixin.
      </p>
<p>
        Once you have mixins, you can combine them into objects. Adding or removing
        mixins to an object will internally instantiate them (via their default constructor)
        or destroy them. This means that a mixin instance is bound to an object instance.
        While it can be accessed via <code class="computeroutput"><span class="identifier">object</span><span class="special">::</span><span class="identifier">get</span></code>,
        the mixin instance cannot be "removed" from an object, while also
        preserving it. Objects cannot share mixin instances.
      </p>
<p>
        You can think of mixins as the multiple parents of a class, when using multiple
        inheritance. Only in the case of Boost.Mixin, they can be added and removed
        dynamically, while preserving the state of the rest.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.glossary.message"></a><a class="link" href="glossary.html#boost_mixin.glossary.message" title="Messages">Messages</a>
</h3></div></div></div>
<p>
        <a class="indexterm" name="idp5438304"></a>
      </p>
<p>
        Messages in Boost.Mixin are a way of calling the methods of the mixins that
        comprise an object. You can think of messages as the methods of an object.
        Unfortunately C++ doesn't allow extension methods (as for example C# does)
        and to call an object's message, you need to write <code class="computeroutput"><span class="identifier">message</span><span class="special">(</span><span class="identifier">object</span><span class="special">,</span> <span class="identifier">params</span><span class="special">...)</span></code>, instead of the much nicer <code class="computeroutput"><span class="identifier">object</span><span class="special">-&gt;</span><span class="identifier">message</span><span class="special">(</span><span class="identifier">params</span><span class="special">...)</span></code>.
      </p>
<p>
        The methods from your mixins, that will also become messages, cannot be inferred
        from the mixin class. There are macros that let you define a message's name
        and signature. Then, when defining the mixin (with its macro), you need to
        specify which messages it will implement. You will get a compilation error
        if the class, you've made into a mixin, doesn't have the method with the
        appropriate name and signature.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.glossary.message.multicast"></a><a class="link" href="glossary.html#boost_mixin.glossary.message.multicast" title="Multicast messages">Multicast messages</a>
</h4></div></div></div>
<p>
          <a class="indexterm" name="idp5449328"></a>
        </p>
<p>
          One key difference between messages and methods is the multicast mechanism,
          introduced by Boost.Mixin. For example consider the case when you add several
          mixins that implement the same message to an object and then call this
          message.
        </p>
<p>
          In the regular case one (at random) of those mixin will handle it. But
          if you define the message as a <span class="emphasis"><em>multicast</em></span>, all of them
          will. This is very useful for cases such as information gathering (say
          with a message like <code class="computeroutput"><span class="identifier">trace</span> <span class="special">(</span><span class="identifier">std</span><span class="special">::</span><span class="identifier">ostream</span><span class="special">&amp;</span> <span class="identifier">out</span><span class="special">)</span></code>)
        </p>
</div>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.glossary.priority"></a><a class="link" href="glossary.html#boost_mixin.glossary.priority" title="Message priority">Message priority</a>
</h3></div></div></div>
<p>
        <a class="indexterm" name="idp5458688"></a>
 <a class="indexterm" name="idp5459440"></a>
      </p>
<p>
        A message priority can be used for both unicast and multicast messages. In
        both cases it's only relevant when multiple mixins in an object implement
        the same message. The priority is a signed integer with default value: 0.
      </p>
<p>
        For a unicast (regular) message, the mixin with the highest message priority
        will handle it. If multiple mixins have the same priority, it cannot be determined
        which one of the it will be. It will be the same issue as the order of global
        object initialization.
      </p>
<p>
        For a multicast message, the order of the mixins that handle it will be
        <span class="emphasis"><em>descending</em></span> by priority. The order between mixins with
        the same priority cannot be defined. It's related to both global object initialization
        and how the unstable <code class="computeroutput"><span class="identifier">std</span><span class="special">::</span><span class="identifier">sort</span></code>
        handles equal values.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.glossary.combinators"></a><a class="link" href="glossary.html#boost_mixin.glossary.combinators" title="Multicast result combinators">Multicast result combinators</a>
</h3></div></div></div>
<p>
        <a class="indexterm" name="idp5466624"></a>
 <a class="indexterm" name="idp5467376"></a>
      </p>
<p>
        When calling multicast messages, their return values are lost. Naturally,
        you can use an output parameter to collect those return values, but if you
        don't want to change existing methods, or if don't want to have the collection
        logic in them, the library provides a way to collect the return values externally.
      </p>
<p>
        This happens with multicast result combinators.
      </p>
<p>
        The library provides some common combinators, like <code class="computeroutput"><span class="identifier">boolean_or</span></code>,
        <code class="computeroutput"><span class="identifier">boolean_and</span></code>, and <code class="computeroutput"><span class="identifier">sum</span></code>. It also allows you to easily create
        your own, for whatever purpose you need.
      </p>
</div>
<div class="section">
<div class="titlepage"><div><div><h3 class="title">
<a name="boost_mixin.glossary.mutation"></a><a class="link" href="glossary.html#boost_mixin.glossary.mutation" title="Mutations">Mutations</a>
</h3></div></div></div>
<p>
        <a class="indexterm" name="idp5474912"></a>
      </p>
<p>
        A mutation changes the type of an object. You have to use some kind of mutator
        to give type to the object.
      </p>
<p>
        Basically a mutation adds or removes mixins from an object.
      </p>
<div class="section">
<div class="titlepage"><div><div><h4 class="title">
<a name="boost_mixin.glossary.mutation.mrules"></a><a class="link" href="glossary.html#boost_mixin.glossary.mutation.mrules" title="Mutation rules">Mutation rules</a>
</h4></div></div></div>
<p>
          <a class="indexterm" name="idp5478208"></a>
        </p>
<p>
          A mutation rule is set globally applied to all mutations. A mutation rule
          may prevent a mixin to be added to an object or force one, even though
          the mutation wants to add it or doesn't mention it.
        </p>
<p>
          A very common mutation rule is to have mutually exclusive mixins, where
          when you add one, the other is removed.
        </p>
</div>
</div>
</div>
<table xmlns:rev="http://www.cs.rpi.edu/~gregod/boost/tools/doc/revision" width="100%"><tr>
<td align="left"></td>
<td align="right"><div class="copyright-footer">Copyright &#169; 2013, 2014 Borislav Stanimirov, Zahary Karadjov<p>
        Distributed under the Boost Software License, Version 1.0. (See accompanying
        file LICENSE_1_0.txt or copy at <a href="http://www.boost.org/LICENSE_1_0.txt" target="_top">http://www.boost.org/LICENSE_1_0.txt</a>).
      </p>
</div></td>
</tr></table>
<hr>
<div class="spirit-nav">
<a accesskey="p" href="using.html"><img src="../images/prev.png" alt="Prev"></a><a accesskey="u" href="../index.html"><img src="../images/up.png" alt="Up"></a><a accesskey="h" href="../index.html"><img src="../images/home.png" alt="Home"></a><a accesskey="n" href="tutorials.html"><img src="../images/next.png" alt="Next"></a>
</div>
</body>
</html>
